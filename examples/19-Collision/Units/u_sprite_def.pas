unit u_sprite_def;

{$mode ObjFPC}{$H+}

interface

uses
  Classes, SysUtils,
  OGLCScene;


type


{ TStar }

TStar = class(TSprite)
  constructor Create(aTex: PTexture);
  procedure Update(const AElapsedTime: single); override;
end;

{ TMeteor }

TMeteor = class(TSprite)
private
  FDebug: TShapeOutline;
  FAtlas: TOGLCTextureAtlas;
  FHitCount: integer;
  procedure Explode;
public
  constructor Create(aAtlas: TOGLCTextureAtlas);
  procedure Update(const AElapsedTime: single); override;
  procedure Hit;
  procedure CollisionBoxVisible(AValue: boolean);
end;

{ TLaserBullet }

TLaserBullet = class(TSprite)
  procedure Update(const AElapsedTime: single); override;
  procedure DoCollisionTestWithMeteor;
end;

{ TPlayerShip }

TPlayerShip = class(TSprite)
private
  FRadar, FCanonL, FCanonR: TSprite;
  FTexLaser: PTexture;
  FCanonTimeCooling: single;
  FCanonSide, FInvulnerability: boolean;
  FDebug1, FDebug2: TShapeOutline;
public
  constructor Create(aAtlas: TOGLCTextureAtlas);
  procedure Update(const AElapsedTime: single); override;
  procedure ProcessMessage({%H-}UserValue: TUserMessageValue); override;

  procedure Move(aDelta: single);
  procedure Shoot;
  function DoCollisionTestWithMeteor: boolean;
  procedure CollisionBoxVisible(AValue: boolean);
end;

function PathToDataFolder: string;

implementation
uses u_common, BGRABitmapTypes, Forms;

function PathToDataFolder: string;
begin
  Result := Application.Location+'..'+DirectorySeparator+'Data'+DirectorySeparator;
end;

{ TMeteor }

procedure TMeteor.Explode;
var pe: TParticleEmitter;
begin
  KillDefered(0.25);
  if FDebug <> NIL then FDebug.KillDefered(0.24);
  // particle emitter for ship engine
  pe := TParticleEmitter.Create(FScene);
  FScene.Add(pe, LAYER_FX);
  // Load the particle emitter configuration: the file '.par' are generated by the ParticleEditor tool.
  // Because:
  //         1) the file .par have a reference to an image file for the texture used by the particle emitter
  //         2) this texture is already loaded in our atlas
  // -> we specify the atlas instance where the load method will search the relevant file.
  pe.LoadFromFile(PathToDataFolder+'SpaceExplosion.par', FAtlas);
  pe.SetCoordinate(GetXY);
  pe.Shoot;
  pe.KillDefered(1.0);
end;

constructor TMeteor.Create(aAtlas: TOGLCTextureAtlas);
var tex: PTexture;
  zoom: single;
  b: byte;
begin
  FAtlas := aAtlas;
  tex := aAtlas.RetrieveTextureByFileName('SpaceMeteor.svg');
  inherited Create(tex, False);
  FScene.Add(Self, LAYER_METEOR);
  X.Value := Random(FScene.Width-Width);  // set a random horizontal coordinate
  Y.Value := -Height;      // the meteor start from the top of the scene
  zoom := 0.5 + Random*0.8;
//  Scale.Value := PointF(zoom, zoom);          // scale the sprite
  Speed.y.Value := FScene.ScaleDesignToSceneF(100 + Random*50);  // set the vertical speed
  b := Random(192)+64;
  Tint.Value := BGRA(0,0,b,80);         // modify the color
  Angle.AddConstant((Random(20)-10)*3); // add a rotation effect

  FDebug := TShapeOutline.Create(FScene);
  FDebug.SetShapeEllipse(X.Value, Y.Value, Round(Width*0.844), Round(Width*0.844));
  FDebug.SetParam(2.0, BGRA(255,0,0), lpInside, True);
  FScene.Add(FDebug, LAYER_GUI);
  FDebug.BindCenterToSprite(Self);
  FDebug.Visible := FShowCollisionBox;
end;

procedure TMeteor.Update(const AElapsedTime: single);
begin
  inherited Update(AElapsedTime);
  // we kill the meteor when it disappear at the bottom of the scene.
  if Y.Value > FScene.Height then begin
    Kill;
    if FDebug <> NIL then FDebug.Kill;
  end;
end;

procedure TMeteor.Hit;
begin
  inc(FHitCount);
  if FHitCount = 1 then Explode;
end;

procedure TMeteor.CollisionBoxVisible(AValue: boolean);
begin
  FDebug.Visible := AValue;
end;

{ TLaserBullet }

procedure TLaserBullet.Update(const AElapsedTime: single);
begin
  inherited Update(AElapsedTime);
  // kill the laser when it is out of the scene
  if Y.Value + Height < 0 then Kill;
end;

// principe: the meteor is treated as a circle little smaller than the sprite itself.
//           the bullet is treated as a rectangle.
//           we call CollisionCircleVersusRectF function to know if the collision occurs.
procedure TLaserBullet.DoCollisionTestWithMeteor;
var i: integer;
  meteor: TSimpleSurfaceWithEffect;
  ptCenter: TPointF;
  radius: single;
  r: TRectF;
begin
  // define the TRectF of this laser instance
  r.TopLeft := GetXY;
  r.Bottom := Y.Value + Height;
  r.Right := X.Value + Width;

  for i:=0 to FScene.Layer[LAYER_METEOR].SurfaceCount-1 do begin
    meteor := FScene.Layer[LAYER_METEOR].Surface[i];

    // retrieve the center coordinates of the meteor and compute a little smaller radius
    ptCenter := meteor.Center;
    radius := meteor.Width*0.844*0.5;

    if FScene.Collision.CircleRectF(ptCenter, radius, r) then begin
      Kill;  // kill the laser
      TMeteor(meteor).Hit; // we are sure there are only TMeteor instance in layer LAYER_METEOR
      exit;
    end;
  end;
end;

{ TPlayerShip }

constructor TPlayerShip.Create(aAtlas: TOGLCTextureAtlas);
var tex: PTexture;
  s: string;
  pe: TParticleEmitter;
begin
  // we retrieve textures for the ship in the atlas, by their filename (without path)
  tex := aAtlas.RetrieveTextureByFileName('SpaceShip.svg');
  inherited Create(tex, False);
  FScene.Add(Self, LAYER_PLAYER);
  CenterX := FScene.Center.x;
  Y.Value := FScene.Height;
  Y.ChangeTo(FScene.Height-Height*2, 2.0, idcStartFastEndSlow);  // then ship enter in scene by the bottom

  // radar
  tex := aAtlas.RetrieveTextureByFileName('SpaceShipRadar.svg');
  FRadar := TSprite.Create(tex);
  AddChild(FRadar, 0);
  FRadar.CenterX := Width*0.5;
  FRadar.CenterY := Height*0.9;
  FRadar.Pivot := PointF(0.5, 0.8);
  // to animate the radar, we write a scenario on the fly
  s := 'RotateTo 80 3.0 idcsinusoid'#10+            // ask a rotation of 80° in 3.0sec with the velocity curve 'sinusoid'
       'Wait 3.0'#10+                               // wait until the rotation is done
       'RotateTo -80 3.0 idcsinusoid'#10+           // ask a rotation to -80° in 3.0sec with the velocity curve 'sinusoid'
       'Wait 3.0'#10+                               // wait until the rotation is done
       'Loop';                                      // loop to the beginning

  FRadar.AddAndPlayScenario(s);      // add the scenario to our radar and play it immediatly

  // left canon
  tex := aAtlas.RetrieveTextureByFileName('SpaceShipCanon.svg');
  FCanonL := TSprite.Create(tex);
  AddChild(FCanonL, 0);
  FCanonL.CenterX := Width*0.22;
  FCanonL.CenterY := Height*0.6;
  FCanonL.Pivot := PointF(0.5, 0.6);

  // right canon
  FCanonR := TSprite.Create(tex);
  AddChild(FCanonR, 0);
  FCanonR.CenterX := Width*0.80;
  FCanonR.CenterY := Height*0.6;
  FCanonR.Pivot := PointF(0.5, 0.6);

  // particle emitter for ship engine
  pe := TParticleEmitter.Create(FScene);
  AddChild(pe, -1);
  // Load the particle emitter configuration: the file '.par' are generated by the ParticleEditor tool.
  // Because:
  //         1) the file .par have a reference to an image file for the texture used by the particle emitter
  //         2) this texture is already loaded in our atlas
  // -> we specify the atlas instance where the load method will search the relevant file.
  pe.LoadFromFile(PathToDataFolder+'SpaceShipEngine.par', aAtlas);
  pe.ParticlesPosRelativeToEmitterPos := False;
  pe.SetCoordinate(Width*0.5, Height);


  FDebug1 := TShapeOutline.Create(FScene);
  FDebug1.SetShapeRectangle(0, 0, Round(Width*0.29), Round(Height*0.5));
  FDebug1.SetParam(2.0, BGRA(255,0,0), lpInside, True);
  FScene.Add(FDebug1, LAYER_GUI);
  FDebug1.BindToSprite(Self, (Width - FDebug1.Width)*0.5, 0);
  FDebug1.Visible := FShowCollisionBox;

  FDebug2 := TShapeOutline.Create(FScene);
  FDebug2.SetShapeRectangle(0, 0, Width, Round(Height*0.35));
  FDebug2.SetParam(2.0, BGRA(255,0,0), lpInside, True);
  FScene.Add(FDebug2, LAYER_GUI);
  FDebug2.BindToSprite(Self, 0, Height*0.5);
  FDebug2.Visible := FShowCollisionBox;

  FTexLaser := aAtlas.RetrieveTextureByFileName('SpaceShipLaser.svg');
end;

procedure TPlayerShip.Update(const AElapsedTime: single);
begin
  inherited Update(AElapsedTime);

  FCanonTimeCooling := FCanonTimeCooling - AElapsedTime;
  if FCanonTimeCooling < 0 then FCanonTimeCooling := 0;
end;

procedure TPlayerShip.ProcessMessage(UserValue: TUserMessageValue);
begin
  case UserValue of
    // ANIMATION PLAYER IS HIT BY METEOR
    100: begin
      FInvulnerability := True;
      Tint.Value := BGRA(255,255,255,220);
      Blink(-1, 0.2, 0.2);
      FRadar.Tint.Value := BGRA(255,255,255,220);
      FRadar.Blink(-1, 0.2, 0.2);
      FCanonL.Tint.Value := BGRA(255,255,255,220);
      FCanonL.Blink(-1, 0.2, 0.2);
      FCanonR.Tint.Value := BGRA(255,255,255,220);
      FCanonR.Blink(-1, 0.2, 0.2);
      PostMessage(101, 3);
    end;
    101: begin
      StopBlink;
      Tint.Alpha.Value := 0;
      FRadar.StopBlink;
      FRadar.Tint.Alpha.Value := 0;
      FCanonL.StopBlink;
      FCanonL.Tint.Alpha.Value := 0;
      FCanonR.StopBlink;
      FCanonR.Tint.Alpha.Value := 0;
      FInvulnerability := False;
    end;
  end;
end;

procedure TPlayerShip.Move(aDelta: single);
begin
  X.Value := X.Value + aDelta;
  // avoid the ship go out of the scene
  if X.Value < 0 then X.Value := 0;
  if X.Value > FScene.Width-Width then X.Value := FScene.Width-Width;

end;

procedure TPlayerShip.Shoot;
var p: TPointF;
  laser: TLaserBullet;
begin
  if FCanonTimeCooling > 0 then exit;
  FCanonTimeCooling := 0.1; // the delay before another shoot
  FCanonSide := not FCanonSide;  // we toggle the side of the shoot
  if FCanonSide then p.x := FCanonL.CenterX
    else p.x := FCanonR.CenterX;
  p.Y := FCanonR.Y.Value;
  // converts coordinate relative to the ship to coordinate relative to the scene
  p := SurfaceToScene(p);

  laser := TLaserBullet.Create(FTexLaser, False);
  FScene.Add(laser, LAYER_LASER);
  laser.CenterX := p.x;
  laser.BottomY := p.y;
  laser.Speed.y.Value := -FScene.Height*1.5;  // the distance traveled by the laser in 1s
end;

// principe: the ship is treated as two rectangle, due to its shape.
//           the meteor is treated as a circle a little smaller the the meteor itself.
//           we use two time CollisionCircleVersusRectF to check if a collision occurs
//    ***
//    * *
//    ***
//  *******    <- height/2
//  *     *
//  *******
function TPlayerShip.DoCollisionTestWithMeteor: boolean;
var i: integer;
  meteor: TSimpleSurfaceWithEffect;
  ptCenter: TPointF;
  radius: single;
  r1, r2: TRectF;
begin
  if FInvulnerability then exit(False);

  // define the 2 TRectF of the ship instance
  r1.Left := CenterX - Width*0.29*0.5;
  r1.Top := Y.Value;
  r1.Bottom := r1.Top + Height*0.5;
  r1.Right := r1.Left + Width*0.29;

  r2.Left := X.Value;
  r2.Top := Y.Value + Height*0.5;
  r2.Right := RightX;
  r2.Bottom := r2.Top + Height*0.35;

  for i:=0 to FScene.Layer[LAYER_METEOR].SurfaceCount-1 do begin
    meteor := FScene.Layer[LAYER_METEOR].Surface[i];
    // retrieve the center coordinates of the meteor and compute a little smaller radius
    ptCenter := meteor.Center;
    radius := meteor.Width*0.844*0.5;

    Result := FScene.Collision.CircleRectF(ptCenter, radius, r1);
    if not Result then Result := FScene.Collision.CircleRectF(ptCenter, radius, r2);
    if Result then begin
      PostMessage(100); // start animation when ship hurts a meteor
      exit;
    end;
  end;
end;

procedure TPlayerShip.CollisionBoxVisible(AValue: boolean);
begin
  FDebug1.Visible := AValue;
  FDebug2.Visible := AValue;
end;

{ TStar }

constructor TStar.Create(aTex: PTexture);
var zoom: single;
  b: byte;
begin
  inherited Create(aTex, False);
  FScene.Add(Self, LAYER_BACK);
  X.Value := Random(FScene.Width-Width);  // set a random horizontal coordinate
  Y.Value := -Height;      // the star start from the top of the scene
  zoom := 0.5 + Random*0.8;
  Scale.Value := PointF(zoom, zoom);          // scale the sprite
  Speed.y.Value := (100 + Random*50) * zoom;  // set the vertical speed
  b := Random(192)+64;
  Tint.Value := BGRA(b,b,50);                 // set the color
  Angle.AddConstant(Random(180));             // add a rotation effect
end;

procedure TStar.Update(const AElapsedTime: single);
begin
  inherited Update(AElapsedTime);
  // we kill the star when it disappear at the bottom of the scene.
  if Y.Value > FScene.Height then Kill;
end;


end.

