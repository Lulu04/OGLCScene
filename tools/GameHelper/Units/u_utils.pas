unit u_utils;

{$mode ObjFPC}{$H+}
{$modeswitch TypeHelpers}
{$modeswitch AdvancedRecords}

interface

uses
  Classes, SysUtils, Graphics,
  BGRABitmap, BGRABitmapTypes,
  OGLCScene, u_surface_list;

// return the size of an png, jpg, bmp image
function GetImageSize(const aFilename: string): TSize;
function GetSVGImageSize(const aSVGFilename: string): TSize;

function PPIScale(AValue: integer): integer;
function PPIScaleF(AValue: single): single;

// Return the color:  c + c*percent   with percent]-1..1[
function PercentColor(c: TColor; percent: single): TColor;

// utils for array of integer
type

{ TArrayOfIntegerHelper }

TArrayOfIntegerHelper = type helper for TArrayOfInteger
  function Count: integer; inline;
  function Have(aValue: integer): boolean;
  function IndexOf(aValue: integer): integer;
  procedure Add(aValue: integer);
  procedure AddOnlyOneTime(aValue: integer);
  procedure SortFromSmallToHigh;
end;

// return True if the passed class type use a texture
function ChildClassTypeIsTextured(const aClassName: string): boolean;


procedure ReplaceStringInFile(const aTextFilename, aStringToReplace, aNewString: string);

// utils to export pascal unit
  function IsALetter(const c: char; aAcceptUnderscore: boolean): boolean;
  function IsANumber(const c: char): boolean;
  function IsValidLazarusProjectName(const s: string; aShowMessageBoxIfFail: boolean): boolean;
  function IsValidPascalVariableName(const s: string; aShowMessageBoxIfFail: boolean): boolean;
  function IsValidFilename(const s: string): boolean;
  // ex: from 'Units\Sprites\u_sprite_car.pas'
  // return 'Units'+PathDelim+'Sprites'+PathDelim+'u_sprite_car.pas'
  function GetCrossPlatformShortFilename(const aShortFilename: string): string;
  const CHARS_NOT_ALLOWED: set of char=['~','|','#','{','}','[',']'];
  // Return True is the text don't have the not allowed characters.
  function CheckCharacterAllowedInKeyboardInput(const aText: string): boolean;
  function ReplaceCharacterNotAllowedByUnderscore(const aText: string): string;

type

{ TCodeGenerator }

TCodeGenerator = record
  function BooleanToPascal(const aValue: boolean): string;
  function PointFToPascal(const aX, aY: single): string; overload;
  function PointFToPascal(const aPt: TPointF): string; overload;
  function BGRAToPascal(aColor: TBGRAPixel): string;
  function BGRAGradientTypeToPascal(aGradientType: TGradientType): string;
  function FontStyleToPascal(aFontStyle: TFontStyles): string;
  function TextAlignmentToPascal(aAlign: TOGLCAlignment): string;
  // insert LineEnding and double quote
  function TextToPascal(const aText: string; aUseSharp10: boolean=False): string;
  function CheckShapeToPascal(aCheckShape: TUICheckShape): string;
  function CheckFillToPascal(aCheckFill: TUICheckFill): string;
  function UIOrientationToPascal(AValue: TUIOrientation): string;

  procedure CommonPropertiesToPascalCode(t: TStringList;
                                        aSurface: PSurfaceDescriptor;
                                        const aSpacePrefix: string);
  procedure ExtraPropertiesToPascalCode(t: TStringList;
                                       aItem: PSurfaceDescriptor;
                                       const aSpacePrefix: string);

  function Generate_AngleChangeTo(aAngle: single; const aSurfaceName: string): string;
  function Generate_ScaleChangeTo(aScaleX, aScaleY: single; const aSurfaceName: string): string;
  function FormatXCoorRelativeToParentWidth(aX: single; const aSurfaceName: string): string;
  function FormatYCoorRelativeToParentHeight(aY: single; const aSurfaceName: string): string;


  // add only 'File generated by GameHelper, tool provided with OGLCScene library.'
  procedure AddFileGeneratedByGameHelper(t: TStringList);
  // add unit name, compilation mode, uses clause, type
  procedure AddInterface(t: TStringList; const aUnitName: string);
  procedure AddDeclarationOfDecorClass(t: TStringList; const aClassName: string);
  procedure AddDeclarationOfProtectedFlipHAndFlipVForApplySymmetryWhenFlip(t: TStringList);
  procedure AddDeclarationOfClassLoadTexture(t: TStringList);
  procedure AddDeclarationOfSurfaceConstructor(t: TStringList);
  procedure AddDeclarationOfProcessMessage(t: TStringList);
  procedure AddDeclarationOfUpdate(t: TStringList);
  // add implementation + lineending
  procedure AddImplementation(t: TStringList);
  // add the implementation of ScaleWF and ScaleHF
  procedure AddImplementationOfDecorProtectedMethod(t: TStringList; const aDecorClassName: string);
  procedure AddImplementationOfDecorBuildLevel(t: TStringList; const aDecorClassName: string);
  procedure AddImplementationOfProcessMessage(t: TStringList; const aClassName: string);
  procedure AddImplementationOfUpdate(t: TStringList; const aClassName: string);
end;

var CodeGen: TCodeGenerator;

// return a TStringList that contains data to describe an empty oglc project
function GetEmptyOGLCProjectContent: TStringList;
// save data to describe an empty oglc project into the specified filename.
// oglc project are saved in sub-folder GameHelperSave\ProjectConfig.oglc
// in the directory of the target Lazarus project
procedure SaveEmptyOGLCProject(const aFilename: string);

implementation

uses u_common, u_levelbank, u_ui_objectlist, Math, Dialogs, BGRASVG;

function GetImageSize(const aFilename: string): TSize;
var ima: TBGRABitmap;
begin
  ima := TBGRABitmap.Create(aFilename);
  Result.cx := ima.Width;
  Result.cy := ima.Height;
  ima.Free;
end;

function GetSVGImageSize(const aSVGFilename: string): TSize;
var svg: TBGRASVG;
begin
  svg := TBGRASVG.Create(aSVGFileName);
  Result.cx := Round(svg.WidthAsPixel);
  Result.cy := Round(svg.HeightAsPixel);
  svg.Free;
end;

function PPIScale(AValue: integer): integer;
begin
  Result := FScene.ScaleDesignToScene(AValue);
end;

function PPIScale(AValue: single): single;
begin
  Result := FScene.ScaleDesignToSceneF(AValue);
end;

function PPIScaleF(AValue: single): single;
begin
  Result := FScene.ScaleDesignToSceneF(AValue);
end;

function PercentColor(c: TColor; percent: single): TColor;
var r, g, b: integer;
begin
  r := Red(c);
  g := Green(c);
  b := Blue(c);
  r := EnsureRange(Round(r + ( r * percent )), 0, 255);
  g := EnsureRange(Round(g + ( g * percent )), 0, 255);
  b := EnsureRange(Round(b + ( b * percent )), 0, 255);
  Result := RGBToColor(r, g, b);
end;

function ChildClassTypeIsTextured(const aClassName: string): boolean;
begin
  case aClassName of
    'TSprite', 'TSpriteWithElasticCorner', 'TTiledSprite', 'TPolarSprite',
    'TScrollableSprite', 'TDeformationGrid', 'TSpriteOnPath': Result := True;

     'TShapeOutline', 'TGradientRectangle', 'TQuad4Color', 'TSpriteContainer',
     'TFreeText', 'TFreeTextOnPath', 'TFreeTextClock', 'TFreeTextAligned',
     'TOGLCPathToFollow': Result := False;

     else raise exception.create('"'+aClassName+'" not implemented');
  end;
end;

procedure ReplaceStringInFile(const aTextFilename, aStringToReplace, aNewString: string);
var t: TStringList;
  i: integer;
begin
  t := TStringList.Create;
  t.LoadFromFile(aTextFilename);
  try
    for i:=0 to t.Count-1 do
      t.Strings[i] := t.Strings[i].Replace(aStringToReplace, aNewString, [rfReplaceAll]);
    t.SaveToFile(aTextFilename);
  finally
    t.Free;
  end;
end;

function IsALetter(const c: char; aAcceptUnderscore: boolean): boolean;
begin
  Result := ((aAcceptUnderscore and (c = '_')) or
            (c in ['a'..'z', 'A'..'Z']));
end;

function IsANumber(const c: char): boolean;
begin
  Result := c in ['0'..'9'];
end;

function IsValidLazarusProjectName(const s: string; aShowMessageBoxIfFail: boolean): boolean;
begin
  Result := IsValidPascalVariableName(s, False);

  if aShowMessageBoxIfFail and not Result then
    ShowMessage(''''+s+''' is not a valid file name.'+LineEnding+
                'Please use only characters a..z  A..Z  0..9 and underscore');
end;

function IsValidPascalVariableName(const s: string; aShowMessageBoxIfFail: boolean): boolean;
var i: integer;
begin
  Result := False;

  if Length(s) > 0 then begin
    Result := IsALetter(s[1], False);
    for i:=2 to Length(s) do
     Result := Result or IsALetter(s[i], True) or IsANumber(s[i]);
  end;

  if aShowMessageBoxIfFail and not Result then
    ShowMessage(''''+s+''' is not a valid Pascal identifier.'+LineEnding+
                'Please use only characters a..z  A..Z  0..9 and underscore');
end;

function IsValidFilename(const s: string): boolean;
var i: integer;
begin
  Result := False;
  if Length(s) = 0 then exit;
  Result := True;
  for i:=1 to Length(s) do
   Result := Result or IsALetter(s[i], True) or IsANumber(s[i]);
end;

function GetCrossPlatformShortFilename(const aShortFilename: string): string;
var i: integer;
begin
  Result := system.Copy(aShortFilename, 1, Length(aShortFilename));
  for i:=Length(Result) downto 1 do
   if Result[i] in ['\','/'] then begin
     system.Delete(Result, i, 1);
     system.Insert('''+PathDelim+''', Result, i);
   end;
end;

function CheckCharacterAllowedInKeyboardInput(const aText: string): boolean;
var i: integer;
begin
  for i:=1 to Length(aText) do
    if aText[i] in CHARS_NOT_ALLOWED then exit(False);
  Result := True;
end;

function ReplaceCharacterNotAllowedByUnderscore(const aText: string): string;
var i: integer;
begin
  Result := Copy(aText, 1, Length(aText));
  for i:=1 to Length(Result) do
    if Result[i] in CHARS_NOT_ALLOWED then Result[i] := '_';
end;

function TCodeGenerator.BooleanToPascal(const aValue: boolean): string;
begin
  if aValue then Result := 'True' else Result := 'False';
end;

function TCodeGenerator.PointFToPascal(const aX, aY: single): string;
begin
  Result := 'PointF('+FormatFloatWithDot('0.00', aX)+', '+FormatFloatWithDot('0.00', aY)+')';
end;

function TCodeGenerator.PointFToPascal(const aPt: TPointF): string;
begin
  Result := PointFToPascal(aPt.x, aPt.y);
end;

function TCodeGenerator.BGRAToPascal(aColor: TBGRAPixel): string;
begin
  Result := 'BGRA('+aColor.red.ToString+','+aColor.green.ToString+','+aColor.blue.ToString;
  if aColor.alpha <> 255 then Result := Result + ','+aColor.alpha.ToString;
  Result := Result + ')';
end;

function TCodeGenerator.BGRAGradientTypeToPascal(aGradientType: TGradientType): string;
begin
  WriteStr(Result, aGradientType);
end;

function TCodeGenerator.FontStyleToPascal(aFontStyle: TFontStyles): string;
var count: integer;
  procedure Add(const s: string);
  begin
    if count = 0 then Result := Result+s
      else Result := Result + ', '+s;
    inc(count);
  end;
begin
  count := 0;
  Result := '[';
  if fsBold in aFontStyle then Add('fsBold');
  if fsItalic in aFontStyle then Add('fsItalic');
  if fsUnderline in aFontStyle then Add('fsUnderline');
  if fsStrikeOut in aFontStyle then Add('fsStrikeOut');
  Result := Result + ']';
end;

function TCodeGenerator.TextAlignmentToPascal(aAlign: TOGLCAlignment): string;
var s: string;
begin
  WriteStr(s, aAlign);
  Result := s;
end;

function TCodeGenerator.TextToPascal(const aText: string; aUseSharp10: boolean): string;
const LN = '''+LineEnding+''';
begin
  if Length(aText) = 0 then begin
    Result := '''''';
    exit;
  end;

  Result := StringReplace(aText, #39, #39#39, [rfReplaceAll]);
  Result := StringReplace(Result, #13#10, LN, [rfReplaceAll]);
  Result := StringReplace(Result, #13, LN, [rfReplaceAll]);

  if Result.StartsWith(LN) then system.Delete(Result, 1, 2)
    else Result := '''' + Result;

  if Result.EndsWith(LN) then system.Delete(Result, Length(Result)-1, 2)
    else Result := Result + '''';

  if aUseSharp10 then begin
    Result := StringReplace(Result, '+LineEnding+', '#10', [rfReplaceAll]);
    Result := StringReplace(Result, '+LineEnding', '', [rfReplaceAll]);
  end;
end;

function TCodeGenerator.CheckShapeToPascal(aCheckShape: TUICheckShape): string;
begin
  system.WriteStr(Result, aCheckShape);
end;

function TCodeGenerator.CheckFillToPascal(aCheckFill: TUICheckFill): string;
begin
  system.WriteStr(Result, aCheckFill);
end;

function TCodeGenerator.UIOrientationToPascal(AValue: TUIOrientation): string;
begin
  system.WriteStr(Result, AValue);
end;

procedure TCodeGenerator.CommonPropertiesToPascalCode(t: TStringList;
  aSurface: PSurfaceDescriptor; const aSpacePrefix: string);
const BLEND_NAMES: array[0..3] of string=('FX_BLEND_NORMAL', 'FX_BLEND_ADD', 'FX_BLEND_MULT',
                                          'FX_NOBLEND');
begin
  if (aSurface^.pivotX <> 0.5) or (aSurface^.pivotY <> 0.5) then
    t.Add(aSpacePrefix+'Pivot := '+PointFToPascal(aSurface^.pivotX, aSurface^.pivotY)+';');
  if aSurface^.angle <> 0.0 then
    t.Add(aSpacePrefix+'Angle.Value := '+FormatFloatWithDot('0.00', aSurface^.angle)+';');
  if (aSurface^.scaleX <> 1.0) or (aSurface^.scaleY <> 1.0) then
    t.Add(aSpacePrefix+'Scale.Value := '+PointFToPascal(aSurface^.scaleX, aSurface^.scaleY)+';');
  if aSurface^.flipH then
    t.Add(aSpacePrefix+'FlipH := True;');
  if aSurface^.flipV then
    t.Add(aSpacePrefix+'FlipV := True;');
  if aSurface^.opacity <> 255 then
    t.Add(aSpacePrefix+'Opacity.Value := '+ Round(aSurface^.opacity).ToString+';');
  if aSurface^.tint <> BGRA(0,0,0,0) then
    t.Add(aSpacePrefix+'Tint.Value := '+BGRAToPascal(aSurface^.tint)+';');
  if aSurface^.tintMode <> tmReplaceColor then
    t.Add(aSpacePrefix+'TintMode := tmMixColor;');
  if aSurface^.IsTextured and (aSurface^.frameindex <> 0.0) then
    t.Add(aSpacePrefix+'Frame := '+FormatFloatWithDot('0.0', aSurface^.frameindex)+';');
  if aSurface^.blendmode <> FX_BLEND_NORMAL then
    t.Add(aSpacePrefix+'BlendMode := '+BLEND_NAMES[aSurface^.blendmode]+';');
end;

procedure TCodeGenerator.ExtraPropertiesToPascalCode(t: TStringList;
  aItem: PSurfaceDescriptor; const aSpacePrefix: string);
var
  fontItem: TFontDescriptorItem;
  PathItem: TPathDescriptorItem;
  s, sx: String;
  procedure BodyShapeToPascal;
  begin
    if aItem^.BodyShapeData <> '' then begin
      t.Add(aSpacePrefix+'BodyShape.LoadFromString('''+aItem^.BodyShapeData+''');');
      t.Add(aSpacePrefix+'BodyShape.ResizeCurrentShape(ScaleW('+aItem^.width.ToString+'), ScaleH('+aItem^.height.ToString+'), True);');
    end;
  end;
  procedure BackGradientToPascal;
  var b: TGradientDescriptor;
  begin
    if aItem^.BackGradientData <> '' then begin
      b.InitDefault;
      b.LoadGradientDataFromString(aItem^.BackGradientData);
      if b.Visible then begin
        t.Add(aSpacePrefix+'BackGradient.LoadGradientDataFromString('''+aItem^.BackGradientData+''');');
        t.Add(aSpacePrefix+'BackGradient.ComputeVerticesAndIndices(ScaleW('+aItem^.width.ToString+'), ScaleH('+aItem^.height.ToString+'));');
      end;
    end;
  end;

begin
  case aItem^.classtype.ClassName of
    'TSprite': begin
      t.Add(aSpacePrefix+'SetSize(ScaleW(Round('+aItem^.width.ToString+'*FAdditionnalScale)), ScaleH(Round('+
                aItem^.height.ToString+'*FAdditionnalScale)));');
    end;

    'TSpriteWithElasticCorner': begin
      t.Add(aSpacePrefix+'SetSize(ScaleW(Round('+aItem^.width.ToString+'*FAdditionnalScale)), ScaleH(Round('+
                aItem^.height.ToString+'*FAdditionnalScale)));');
      if (aItem^.TopLeftOffsetX <> 0.0) or (aItem^.TopLeftOffsetY <> 0.0) then
        t.Add(aSpacePrefix+'CornerOffset.TopLeft.Value := PointF(ScaleWF('+FormatFloatWithDot('0.000', aItem^.TopLeftOffsetX)+'), ScaleHF('+FormatFloatWithDot('0.000', aItem^.TopLeftOffsetY)+'));');
      if (aItem^.TopRightOffsetX <> 0.0) or (aItem^.TopRightOffsetY <> 0.0) then
        t.Add(aSpacePrefix+'CornerOffset.TopRight.Value := PointF(ScaleWF('+FormatFloatWithDot('0.000', aItem^.TopRightOffsetX)+'), ScaleHF('+FormatFloatWithDot('0.000', aItem^.TopRightOffsetY)+'));');
      if (aItem^.BottomRightOffsetX <> 0.0) or (aItem^.BottomRightOffsetY <> 0.0) then
        t.Add(aSpacePrefix+'CornerOffset.BottomRight.Value := PointF(ScaleWF('+FormatFloatWithDot('0.000', aItem^.BottomRightOffsetX)+'), ScaleHF('+FormatFloatWithDot('0.000', aItem^.BottomRightOffsetY)+'));');
      if (aItem^.BottomLeftOffsetX <> 0.0) or (aItem^.BottomLeftOffsetY <> 0.0) then
        t.Add(aSpacePrefix+'CornerOffset.BottomLeft.Value := PointF(ScaleWF('+FormatFloatWithDot('0.000', aItem^.BottomLeftOffsetX)+'), ScaleHF('+FormatFloatWithDot('0.000', aItem^.BottomLeftOffsetY)+'));');
    end;

    'TPolarSprite': begin
      t.Add(aSpacePrefix+'SetSize(ScaleW(Round('+aItem^.width.ToString+'*FAdditionnalScale)), ScaleH(Round('+
                aItem^.height.ToString+'*FAdditionnalScale)));');
      t.Add(aSpacePrefix+'Polar.Center.Value := PointF(X.Value+Width*0.5, Y.Value+Height*0.5);'); //+PointFToPascal(aSurface^.x+aSurface^.width*0.5, aSurface^.y+aSurface^.height*0.5)+';');
      if aItem^.PolarAngle <> 0.0 then
        t.Add(aSpacePrefix+'Polar.Angle.Value := '+FormatFloatWithDot('0.00', aItem^.PolarAngle)+';');
      if aItem^.PolarDistance <> 0.0 then
        t.Add(aSpacePrefix+'Polar.Distance.Value := '+FormatFloatWithDot('0.00', aItem^.PolarDistance)+';');
    end;

    'TQuad4Color': begin
      t.Add(aSpacePrefix+'SetSize(ScaleW(Round('+aItem^.width.ToString+'*FAdditionnalScale)), ScaleH(Round('+aItem^.height.ToString+'*FAdditionnalScale)));');
      if (aItem^.TopLeftColor = aItem^.TopRightColor) and
         (aItem^.TopRightColor = aItem^.BottomRightColor) and
         (aItem^.BottomRightColor = aItem^.BottomLeftColor) then begin
        t.Add(aSpacePrefix+'SetAllColorsTo('+BGRAToPascal(aItem^.TopLeftColor)+');');
      end else begin
        t.Add(aSpacePrefix+'TopLeftColor.Value := '+BGRAToPascal(aItem^.TopLeftColor)+';');
        t.Add(aSpacePrefix+'TopRightColor.Value := '+BGRAToPascal(aItem^.TopRightColor)+';');
        t.Add(aSpacePrefix+'BottomRightColor.Value := '+BGRAToPascal(aItem^.BottomRightColor)+';');
        t.Add(aSpacePrefix+'BottomLeftColor.Value := '+BGRAToPascal(aItem^.BottomLeftColor)+';');
      end;
    end;

    'TGradientRectangle': begin
      t.Add(aSpacePrefix+'Gradient.LoadGradientDataFromString('''+aItem^.GradientData+''');');
      t.Add(aSpacePrefix+'SetSize(ScaleW(Round('+aItem^.width.ToString+'*FAdditionnalScale)), ScaleH(Round('+aItem^.height.ToString+'*FAdditionnalScale)));');
    end;

    'TDeformationGrid': begin
      t.Add(aSpacePrefix+'SetSize(ScaleW(Round('+aItem^.width.ToString+'*FAdditionnalScale)), ScaleH(Round('+aItem^.height.ToString+'*FAdditionnalScale)));');
      t.Add(aSpacePrefix+'LoadDeformationDataFromString('''+aItem^.DeformationGridData+''');');
    end;

    'TSpriteContainer': begin
    end;

    'TOGLCPathToFollow': begin
      t.Add(aSpacePrefix+'Border.LoadFromString('''+aItem^.PathToFollowBorderData+''');');
      PathItem := PathBank.GetByName(aItem^.PathDescriptorName);
      if PathItem <> NIL then
        t.Add(aSpacePrefix+'InitFromPath('+PathItem.VariableName+');');
      t.Add(aSpacePrefix+'Loop := '+BooleanToPascal(aItem^.PathToFollowLoop)+';');
    end;

    'TSpriteOnPath': begin
      t.Add(aSpacePrefix+'AutoRotate := '+BooleanToPascal(aItem^.OnPathAutoRotate)+';');
      t.Add(aSpacePrefix+'AngleAdjust := '+FormatFloatWithDot('0.00', aItem^.OnPathAngleAdjust)+';');
      t.Add(aSpacePrefix+'CoeffPositionOnPath := '+FormatFloatWithDot('0.00', aItem^.OnPathCoeffPosition)+';');
    end;

    'TFreeTextOnPath': begin
      t.Add(aSpacePrefix+'Caption := '+TextToPascal(aItem^.Caption)+';');
      fontItem := FontBank.GetByName(aItem^.FontDescriptorName);
      if fontItem <> NIL then
        t.Add(aSpacePrefix+'TexturedFont := '+fontItem.VariableNameForTexturedFont+';');
      t.Add(aSpacePrefix+'AutoRotate := '+BooleanToPascal(aItem^.OnPathAutoRotate)+';');
      t.Add(aSpacePrefix+'AngleAdjust := '+FormatFloatWithDot('0.00', aItem^.OnPathAngleAdjust)+';');
      t.Add(aSpacePrefix+'CoeffPositionOnPath := '+FormatFloatWithDot('0.00', aItem^.OnPathCoeffPosition)+';');
    end;

    'TFreeText': begin
      t.Add(aSpacePrefix+'Caption := '+TextToPascal(aItem^.Caption)+';');
      fontItem := FontBank.GetByName(aItem^.FontDescriptorName);
      if fontItem <> NIL then
        t.Add(aSpacePrefix+'TexturedFont := '+fontItem.VariableNameForTexturedFont+';');
    end;

    'TFreeTextClock': begin
      fontItem := FontBank.GetByName(aItem^.FontDescriptorName);
      if fontItem <> NIL then
        t.Add(aSpacePrefix+'TexturedFont := '+fontItem.VariableNameForTexturedFont+';');
      t.Add(aSpacePrefix+'Time := '+FormatFloatWithDot('0.00', aItem^.TimeValue)+';');
      t.Add(aSpacePrefix+'CountDown := '+CodeGen.BooleanToPascal(aItem^.CountDown)+';');
      t.Add(aSpacePrefix+'ShowFractionalPart := '+CodeGen.BooleanToPascal(aItem^.ClockShowDecimal)+';');
    end;

    'TFreeTextAligned': begin
      {fontItem := FontBank.GetByName(aItem^.FontDescriptorName);
      if fontItem <> NIL then
        t.Add(aSpacePrefix+'TexturedFont := '+fontItem.VariableNameForTexturedFont+';');}
      t.Add(aSpacePrefix+'Caption := '+TextToPascal(aItem^.Caption)+';');
      t.Add(aSpacePrefix+'Align := '+TextAlignmentToPascal(aItem^.TextAlignment)+';');
    end;

    'TUIPanel': begin
      BodyShapeToPascal;
      BackGradientToPascal;
    end;

    'TUIModalPanel': begin
      BodyShapeToPascal;
      BackGradientToPascal;
    end;

    'TUIPanelWithEffects': begin
      BodyShapeToPascal;
      BackGradientToPascal;
      if aItem^.BGDarkenColor.alpha > 0 then
        t.Add(aSpacePrefix+'ActivateSceneDarken('+BGRAToPascal(aItem^.BGDarkenColor)+');');
    end;

    'TUILabel': begin
      fontItem := FontBank.GetByName(aItem^.FontDescriptorName);
      if fontItem <> NIL then
        t.Add(aSpacePrefix+'TexturedFont := '+fontItem.VariableNameForTexturedFont+';');
      t.Add(aSpacePrefix+'Caption := '+TextToPascal(aItem^.Caption)+';');
    end;

    'TUIImage': begin
    end;

    'TUIButton': begin
      if aItem^.AutoSize = False then
        t.Add(aSpacePrefix+'AutoSize := False;');
      if aItem^.CaptionColor.alpha <> 0 then
        t.Add(aSpacePrefix+'_Label.Tint.Value := '+BGRAToPascal(aItem^.CaptionColor)+';');
      fontItem := FontBank.GetByName(aItem^.FontDescriptorName);
      if fontItem <> NIL then s := fontItem.VariableNameForTexturedFont
        else s := 'NIL';
      if aItem^.textureName <> '' then sx := aItem^.textureName
        else sx := 'NIL';
      t.Add(aSpacePrefix+'InitParameters('+CodeGen.TextToPascal(aItem^.Caption)+', '+ s+', '+sx+');');
      BodyShapeToPascal;
      BackGradientToPascal;
    end;

    'TUICheck': begin
      if (aItem^.textureName <> '') and (aItem^.textureName2 <> '') then
        t.Add(aSpacePrefix+'CustomizeCheckBox('+aItem^.textureName+', '+aItem^.textureName2+', '+BooleanToPascal(aItem^.CheckAdjustImageToFontHeight)+');')
      else t.Add(aSpacePrefix+'CustomizeCheckBox('+CheckShapeToPascal(aItem^.CheckShape)+', '+CheckFillToPascal(aItem^.CheckFill)+');');
      if aItem^.Checked then
        t.Add(aSpacePrefix+'Checked := '+BooleanToPascal(aItem^.Checked)+';');
      t.Add(aSpacePrefix+'ColorChecked := '+BGRAToPascal(aItem^.CheckColorChecked)+';');
      if aItem^.CaptionColor.alpha <> 0 then
        t.Add(aSpacePrefix+'_Label.Tint.Value := '+BGRAToPascal(aItem^.CaptionColor)+';');
    end;

    'TUIRadio': begin
      if (aItem^.textureName <> '') and (aItem^.textureName2 <> '') then
        t.Add(aSpacePrefix+'CustomizeCheckBox('+aItem^.textureName+', '+aItem^.textureName2+', '+BooleanToPascal(aItem^.CheckAdjustImageToFontHeight)+');')
      else t.Add(aSpacePrefix+'CustomizeCheckBox('+CheckShapeToPascal(aItem^.CheckShape)+', '+CheckFillToPascal(aItem^.CheckFill)+');');
      if aItem^.Checked then
        t.Add(aSpacePrefix+'Checked := '+BooleanToPascal(aItem^.Checked)+';');
      t.Add(aSpacePrefix+'ColorChecked := '+BGRAToPascal(aItem^.CheckColorChecked)+';');
      if aItem^.CaptionColor.alpha <> 0 then
        t.Add(aSpacePrefix+'_Label.Tint.Value := '+BGRAToPascal(aItem^.CaptionColor)+';');
    end;

    'TUIScrollBar': begin
      BodyShapeToPascal;
      BackGradientToPascal;
      t.Add(aSpacePrefix+'SetParams('+aItem^.scrollbarPosition.ToString+', '+
                                      aItem^.scrollbarMin.ToString+', '+
                                      aItem^.scrollbarMax.ToString+', '+
                                      aItem^.scrollbarPageSize.ToString+');');
    end;
    'TUIProgressBar': begin
      BodyShapeToPascal;
      if aItem^.GradientData <> '' then begin
        t.Add(aSpacePrefix+'Gradient.LoadGradientDataFromString('''+aItem^.GradientData+''');');
        t.Add(aSpacePrefix+'Gradient.ComputeVerticesAndIndices(ScaleW('+aItem^.width.ToString+'), ScaleH('+aItem^.height.ToString+'));');
      end;
      if aItem^.ProgressBarReversed then
        t.Add(aSpacePrefix+'Reversed := '+BooleanToPascal(aItem^.ProgressBarReversed)+';');
      t.Add(aSpacePrefix+'Percent := '+FormatFloatWithDot('0.000', aItem^.ProgressBarPercent)+';');
    end;

    'TUIScrollBox': begin
      BodyShapeToPascal;
      BackGradientToPascal;
    end;

    'TUIListBox': begin
      BodyShapeToPascal;
      BackGradientToPascal;
      t.Add(aSpacePrefix+'ItemHeight := '+aItem^.listboxItemHeight.ToString+';');
      t.Add(aSpacePrefix+'MultiSelect := '+BooleanToPascal(aItem^.listboxMultiSelect)+';');
      t.Add(aSpacePrefix+'ItemColor.GradientItem.LoadGradientDataFromString('''+aItem^.listboxUnselectedGradientData+''');');
      t.Add(aSpacePrefix+'ItemColor.ColorText := '+BGRAToPascal(aItem^.listboxUnselectedTextColor)+';');
      t.Add(aSpacePrefix+'ItemColor.GradientItemSelected.LoadGradientDataFromString('''+aItem^.listboxSelectedGradientData+''');');
      t.Add(aSpacePrefix+'ItemColor.ColorSelectedText := '+BGRAToPascal(aItem^.listboxSelectedTextColor)+';');
    end;

    'TUITextArea': begin
      BodyShapeToPascal;
      BackGradientToPascal;
      fontItem := FontBank.GetByName(aItem^.FontDescriptorName);
      if fontItem <> NIL then
        t.Add(aSpacePrefix+'Text.TexturedFont := '+fontItem.VariableNameForTexturedFont+';');
      t.Add(aSpacePrefix+'Text.Tint.Value := '+BGRAToPascal(aItem^.TextAreaTextTint)+';');
      t.Add(aSpacePrefix+'Text.Caption := '+TextToPascal(aItem^.TextAreaText)+';');
      t.Add(aSpacePrefix+'Text.Align := '+TextAlignmentToPascal(aItem^.TextAlignment)+';');
    end

    else raise exception.Create('forgot to implement '+aItem^.classtype.ClassName);
  end;
end;

function TCodeGenerator.Generate_AngleChangeTo(aAngle: single; const aSurfaceName: string): string;
begin
  Result :='  '+aSurfaceName+'.Angle.ChangeTo(';
  if aAngle = 0 then Result := Result+'0'
    else Result := Result+FormatFloatWithDot('0.000', aAngle);
  Result := Result+', aDuration, aVelocityCurve);';
end;

function TCodeGenerator.Generate_ScaleChangeTo(aScaleX, aScaleY: single;
  const aSurfaceName: string): string;
begin
  Result := '  '+aSurfaceName+'.Scale.ChangeTo(PointF(';
  if aScaleX = 1.0 then Result := Result+'1.0'
    else Result := Result+FormatFloatWithDot('0.000', aScaleX);
  Result := Result + ', ';
  if aScaleY = 1.0 then Result := Result+'1.0'
    else Result := Result+FormatFloatWithDot('0.000', aScaleY);
  Result := Result + '), aDuration, aVelocityCurve);';
end;

function TCodeGenerator.FormatXCoorRelativeToParentWidth(aX: single;
  const aSurfaceName: string): string;
begin
  if aX = 0 then Result := '0'
    else begin
      if aSurfaceName <> '' then
        Result := FormatFloatWithDot('0.000', aX)+'*'+aSurfaceName+'.Width'
      else
        Result := FormatFloatWithDot('0.000', aX)+'*'+'Self.Width';
    end;
end;

function TCodeGenerator.FormatYCoorRelativeToParentHeight(aY: single;
  const aSurfaceName: string): string;
begin
  if aY = 0 then Result := '0'
    else begin
      if aSurfaceName <> '' then
        Result := FormatFloatWithDot('0.000', aY)+'*'+aSurfaceName+'.Height'
      else
        Result := FormatFloatWithDot('0.000', aY)+'*'+'Self.Height';
    end;
end;

procedure TCodeGenerator.AddFileGeneratedByGameHelper(t: TStringList);
begin
  t.Add('  File generated by GameHelper, tool provided with OGLCScene library.');
end;

procedure TCodeGenerator.AddInterface(t: TStringList; const aUnitName: string);
begin
  t.AddText('unit '+aUnitName+';'#10#10+
            '{$mode ObjFPC}{$H+}'#10#10+
            'interface'#10#10+
            'uses'#10+
            '  Classes, SysUtils,'#10+
            '  OGLCScene, BGRABitmap, BGRABitmapTypes, u_common;'#10#10+
            'type'#10#10);
end;

procedure TCodeGenerator.AddDeclarationOfDecorClass(t: TStringList; const aClassName: string);
begin
  t.Add('{ '+aClassName+' }');
  t.Add('');
  t.AddText(aClassName+' = class(TOGLCDecorManager)'#10+
            'protected'#10+
            '  function ScaleWF(AValue: single): single; override;'#10+
            '  function ScaleHF(AValue: single): single; override;'#10+
            'public'#10+
            '  class procedure LoadTexture(aAtlas: TAtlas); override;');
  if WorkingLevelGroup.Size > 1 then t.Add('  procedure BuildLevel(aIndex: integer);')
    else t.Add('  procedure BuildLevel;');
  t.Add('end;'#10);
end;

procedure TCodeGenerator.AddDeclarationOfProtectedFlipHAndFlipVForApplySymmetryWhenFlip(t: TStringList);
begin
  t.AddText('  procedure SetFlipH(AValue: boolean); override;'#10+
            '  procedure SetFlipV(AValue: boolean); override;');
end;

procedure TCodeGenerator.AddDeclarationOfClassLoadTexture(t: TStringList);
begin
  t.Add('  class procedure LoadTexture(aAtlas: TOGLCTextureAtlas);');
end;

procedure TCodeGenerator.AddDeclarationOfSurfaceConstructor(t: TStringList);
begin
  t.Add('  constructor Create(aLayerIndex: integer=-1);');
end;

procedure TCodeGenerator.AddDeclarationOfProcessMessage(t: TStringList);
begin
  t.Add('  procedure ProcessMessage(UserValue: TUserMessageValue); override;');
end;

procedure TCodeGenerator.AddDeclarationOfUpdate(t: TStringList);
begin
  t.Add('  procedure Update(const aElapsedtime: single); override;');
end;

procedure TCodeGenerator.AddImplementation(t: TStringList);
begin
  t.Add('implementation');
  t.Add('');
end;

procedure TCodeGenerator.AddImplementationOfDecorProtectedMethod(t: TStringList; const aDecorClassName: string);
begin
  t.AddText('function '+aDecorClassName+'.ScaleWF(AValue: single): single;'#10+
            'begin'#10+
            '  Result := u_common.ScaleWF(AValue);'#10+
            'end;'#10#10+
            'function '+aDecorClassName+'.ScaleHF(AValue: single): single;'#10+
            'begin'#10+
            '  Result := u_common.ScaleHF(AValue);'#10+
            'end;'#10);
end;

procedure TCodeGenerator.AddImplementationOfDecorBuildLevel(t: TStringList; const aDecorClassName: string);
var i: SizeUInt;
begin
  if WorkingLevelGroup.Size > 1 then begin
    // several decors
    t.AddText('procedure '+aDecorClassName+'.BuildLevel(aIndex: integer);'#10+
              'begin'#10+
              '  case aIndex of');
    for i:=0 to WorkingLevelGroup.Size-1 do
      t.Add('    '+i.ToString+': DoBuildLevel('+'Data_'+WorkingLevelGroup.Mutable[i]^.name+');');
    t.AddText('    else raise exception.create(''level index out of bounds'');'#10+
              '  end;'#10+
              'end;'#10#10);
  end else begin
    // only one decor
    t.AddText('procedure '+aDecorClassName+'.BuildLevel;'#10+
              'begin'#10+
              '  DoBuildLevel('+'Data_'+WorkingLevelGroup.Mutable[0]^.name+');'#10+
              'end;');
  end;
end;

procedure TCodeGenerator.AddImplementationOfProcessMessage(t: TStringList; const aClassName: string);
begin
  t.AddText('procedure '+aClassName+'.ProcessMessage(UserValue: TUserMessageValue);'#10+
            'begin'#10+
            '  case UserValue of'#10+
            '    0: begin'#10+
            '    end;'#10+
            '  end;//case'#10+
            'end;');
  t.Add('');
end;

procedure TCodeGenerator.AddImplementationOfUpdate(t: TStringList; const aClassName: string);
begin
  t.AddText('procedure '+aClassName+'.Update(const aElapsedTime: single);'#10+
            'begin'#10+
            '  inherited Update(aElapsedtime);'#10+
            '  // Add your code here'#10+
            'end;');
  t.Add('');
end;

function GetEmptyOGLCProjectContent: TStringList;
begin
  Result := TStringList.Create;
  Result.Add('[CONFIG]');
  Result.Add('SceneWidth|1024|SceneHeight|768|MaximizeScene|true|LevelEditorOverlap|0.5000|CommonShowFlyingTxt|true');
  //Result.Add('[SPRITE BANK]');
  //Result.Add('0');
  //Result.Add('[LEVEL BANK]');
  //Result.Add('GroupCount{0');
end;

procedure SaveEmptyOGLCProject(const aFilename: string);
var t: TStringList;
begin
  try
    try
      t := GetEmptyOGLCProjectContent;
      t.SaveToFile(aFilename);
      FScene.LogInfo('done', 1);
    except
      On E :Exception do begin
        FScene.LogError('Exception '+E.Message, 1);
      end;
    end;
  finally
    t.Free;
  end;
end;

{ TArrayOfIntegerHelper }

function TArrayOfIntegerHelper.Count: integer;
begin
  Result := Length(Self);
end;

function TArrayOfIntegerHelper.Have(aValue: integer): boolean;
var i: integer;
begin
  for i:=0 to High(Self) do
    if Self[i] = aValue then exit(True);
  Result := False;
end;

function TArrayOfIntegerHelper.IndexOf(aValue: integer): integer;
var i: integer;
begin
  for i:=0 to High(Self) do
    if Self[i] = aValue then exit(i);
  Result := -1;
end;

procedure TArrayOfIntegerHelper.Add(aValue: integer);
begin
  SetLength(Self, Length(Self)+1);
  Self[High(Self)] := aValue;
end;

procedure TArrayOfIntegerHelper.AddOnlyOneTime(aValue: integer);
begin
  if not Have(aValue) then Add(aValue);
end;

procedure TArrayOfIntegerHelper.SortFromSmallToHigh;
var i, k: integer;
  flag: boolean;
begin
  repeat
    flag := False;
    for i:=0 to High(Self)-1 do
      if Self[i] > Self[i+1] then begin
        k := Self[i+1];
        Self[i+1] := Self[i];
        Self[i] := k;
        flag := true;
      end;
  until not flag;
end;

end.

