unit u_utils;

{$mode ObjFPC}{$H+}
{$modeswitch TypeHelpers}

interface

uses
  Classes, SysUtils, Graphics,
  BGRABitmap, BGRABitmapTypes,
  OGLCScene, u_surface_list, u_texture_list, u_posture_list;

// return the size of an png, jpg, bmp image
function GetImageSize(const aFilename: string): TSize;
function GetSVGImageSize(const aSVGFilename: string): TSize;

function PPIScale(AValue: integer): integer;
function PPIScaleF(AValue: single): single;

// Return the color:  c + c*percent   with percent]-1..1[
function PercentColor(c: TColor; percent: single): TColor;

// utils for array of integer
type

{ TArrayOfIntegerHelper }

TArrayOfIntegerHelper = type helper for TArrayOfInteger
  function Count: integer; inline;
  function Have(aValue: integer): boolean;
  function IndexOf(aValue: integer): integer;
  procedure Add(aValue: integer);
  procedure AddOnlyOneTime(aValue: integer);
  procedure SortFromSmallToHigh;
end;

// return True if the passed class type use a texture
function ChildClassTypeIsTextured(const aClassName: string): boolean;


procedure ReplaceStringInFile(const aTextFilename, aStringToReplace, aNewString: string);

// utils to export pascal unit
function IsALetter(const c: char; aAcceptUnderscore: boolean): boolean;
function IsANumber(const c: char): boolean;
function IsValidLazarusProjectName(const s: string): boolean;
function IsValidPascalVariableName(const s: string): boolean;
function IsValidFilename(const s: string): boolean;

function PointFToPascal(const aX, aY: single): string; overload;
function PointFToPascal(const aPt: TPointF): string; overload;
function BGRAToPascal(aColor: TBGRAPixel): string;

function CommonPropertiesToPascalCode(aSurface: PSurfaceDescriptor; const aSpacePrefix: string): string;
function ExtraPropertiesToPascalCode(aSurface: PSurfaceDescriptor; const aSpacePrefix: string): string;

// add only 'File generated by GameHelper, tool provided with OGLCScene library.'
procedure AddFileGeneratedByGameHelper(t: TStringList);
// add unit name, compilation mode, uses clause, type
procedure AddInterface(t: TStringList; const aUnitName: string);
procedure AddDeclarationOfDecorClass(t: TStringList; const aClassName: string);
procedure AddDeclarationOfProtectedFlipHAndFlipVForApplySymmetryWhenFlip(t: TStringList);
procedure AddDeclarationOfClassLoadTexture(t: TStringList);
procedure AddDeclarationOfSurfaceConstructor(t: TStringList);
procedure AddDeclarationOfProcessMessage(t: TStringList);
// add implementation + lineending
procedure AddImplementation(t: TStringList);
// add the implementation of ScaleWF and ScaleHF
procedure AddImplementationOfDecorProtectedMethod(t: TStringList; const aDecorClassName: string);

procedure AddImplementationOfDecorBuildLevel(t: TStringList; const aDecorClassName: string);
procedure AddImplementationOfProcessMessage(t: TStringList; const aClassName: string);


procedure ExportSpriteToPascalUnit(t: TStringList; aTextures: TTextureList;
     aSurfaces: TSurfaceList; aPostures: TPostureList;
     aSpriteNameInBank, aSpriteClassName, aTargetFilename: string;
     aApplySymmetryWhenFlip, aOverrideProcessMessage: boolean);


implementation

uses u_common, u_levelbank, u_spritebank, u_collisionbody_list, Math,
  BGRASVG;

function GetImageSize(const aFilename: string): TSize;
var ima: TBGRABitmap;
begin
  ima := TBGRABitmap.Create(aFilename);
  Result.cx := ima.Width;
  Result.cy := ima.Height;
  ima.Free;
end;

function GetSVGImageSize(const aSVGFilename: string): TSize;
var svg: TBGRASVG;
begin
  svg := TBGRASVG.Create(aSVGFileName);
  Result.cx := Round(svg.WidthAsPixel);
  Result.cy := Round(svg.HeightAsPixel);
  svg.Free;
end;

function PPIScale(AValue: integer): integer;
begin
  Result := FScene.ScaleDesignToScene(AValue);
end;

function PPIScale(AValue: single): single;
begin
  Result := FScene.ScaleDesignToSceneF(AValue);
end;

function PPIScaleF(AValue: single): single;
begin
  Result := FScene.ScaleDesignToSceneF(AValue);
end;

function PercentColor(c: TColor; percent: single): TColor;
var r, g, b: integer;
begin
  r := Red(c);
  g := Green(c);
  b := Blue(c);
  r := EnsureRange(Round(r + ( r * percent )), 0, 255);
  g := EnsureRange(Round(g + ( g * percent )), 0, 255);
  b := EnsureRange(Round(b + ( b * percent )), 0, 255);
  Result := RGBToColor(r, g, b);
end;

function ChildClassTypeIsTextured(const aClassName: string): boolean;
begin
  case aClassName of
    'TSprite', 'TSpriteWithElasticCorner', 'TTiledSprite', 'TPolarSprite',
    'TScrollableSprite', 'TDeformationGrid': Result := True;

     'TShapeOutline', 'TGradientRectangle', 'TQuad4Color', 'TSpriteContainer': Result := False;

     else raise exception.create('"'+aClassName+'" not implemented');
  end;
end;

procedure ReplaceStringInFile(const aTextFilename, aStringToReplace, aNewString: string);
var t: TStringList;
  i: integer;
begin
  t := TStringList.Create;
  t.LoadFromFile(aTextFilename);
  try
    for i:=0 to t.Count-1 do
      t.Strings[i] := t.Strings[i].Replace(aStringToReplace, aNewString, [rfReplaceAll]);
    t.SaveToFile(aTextFilename);
  finally
    t.Free;
  end;
end;

function IsALetter(const c: char; aAcceptUnderscore: boolean): boolean;
begin
  Result := ((aAcceptUnderscore and (c = '_')) or
            (c in ['a'..'z', 'A'..'Z']));
end;

function IsANumber(const c: char): boolean;
begin
  Result := c in ['0'..'9'];
end;

function IsValidLazarusProjectName(const s: string): boolean;
begin
  Result := IsValidPascalVariableName(s);
end;

function IsValidPascalVariableName(const s: string): boolean;
var i: integer;
begin
  Result := False;
  if Length(s) = 0 then exit;
  Result := IsALetter(s[1], False);
  for i:=2 to Length(s) do
   Result := Result or IsALetter(s[i], True) or IsANumber(s[i]);
end;

function IsValidFilename(const s: string): boolean;
var i: integer;
begin
  Result := False;
  if Length(s) = 0 then exit;
  Result := True;
  for i:=1 to Length(s) do
   Result := Result or IsALetter(s[i], True) or IsANumber(s[i]);
end;

function PointFToPascal(const aX, aY: single): string;
begin
  Result := 'PointF('+FormatFloatWithDot('0.00', aX)+', '+FormatFloatWithDot('0.00', aY)+')';
end;

function PointFToPascal(const aPt: TPointF): string;
begin
  Result := PointFToPascal(aPt.x, aPt.y);
end;

function BGRAToPascal(aColor: TBGRAPixel): string;
begin
  Result := 'BGRA('+aColor.red.ToString+','+aColor.green.ToString+','+aColor.blue.ToString;
  if aColor.alpha <> 255 then Result := Result + ','+aColor.alpha.ToString;
  Result := Result + ')';
end;

function CommonPropertiesToPascalCode(aSurface: PSurfaceDescriptor; const aSpacePrefix: string): string;
begin
  Result := '';
  if (aSurface^.pivotX <> 0.5) or (aSurface^.pivotY <> 0.5) then
    Result := Result+aSpacePrefix+'Pivot := '+PointFToPascal(aSurface^.pivotX, aSurface^.pivotY)+';';
  if aSurface^.angle <> 0.0 then
    Result := Result+aSpacePrefix+'Angle.Value := '+FormatFloatWithDot('0.00', aSurface^.angle)+';';
  if (aSurface^.scaleX <> 1.0) or (aSurface^.scaleY <> 1.0) then
    Result := Result+aSpacePrefix+'Scale.Value := '+PointFToPascal(aSurface^.scaleX, aSurface^.scaleY)+';';
  if aSurface^.flipH then
    Result := Result+aSpacePrefix+'FlipH := True;';
  if aSurface^.flipV then
    Result := Result+aSpacePrefix+'FlipV := True;';
  if aSurface^.opacity <> 255 then
    Result := Result+aSpacePrefix+'Opacity.Value := '+ Round(aSurface^.opacity).ToString+';';
  if aSurface^.tint <> BGRA(0,0,0,0) then
    Result := Result+aSpacePrefix+'Tint.Value := '+BGRAToPascal(aSurface^.tint)+';';
  if aSurface^.tintMode <> tmReplaceColor then
    Result := Result+aSpacePrefix+'TintMode := tmMixColor;';
  if aSurface^.IsTextured and (aSurface^.frameindex <> 1.0) then
    Result := Result+aSpacePrefix+'Frame := '+FormatFloatWithDot('0.0', aSurface^.frameindex)+';';
end;

function ExtraPropertiesToPascalCode(aSurface: PSurfaceDescriptor; const aSpacePrefix: string): string;
begin
  case aSurface^.classtype.ClassName of
    'TSprite': begin
      Result := aSpacePrefix+'SetSize(ScaleW('+aSurface^.width.ToString+'), ScaleH('+
                aSurface^.height.ToString+'));';
    end;

    'TQuad4Color': begin
      Result := aSpacePrefix+'SetSize(ScaleW('+aSurface^.width.ToString+'), ScaleH('+aSurface^.height.ToString+'));'#10;
      if (aSurface^.TopLeftColor = aSurface^.TopRightColor) and
         (aSurface^.TopRightColor = aSurface^.BottomRightColor) and
         (aSurface^.BottomRightColor = aSurface^.BottomLeftColor) then begin
        Result := Result + aSpacePrefix+'SetAllColorsTo('+BGRAToPascal(aSurface^.TopLeftColor)+');';
      end else begin
        Result := Result + aSpacePrefix+'TopLeftColor.Value := '+BGRAToPascal(aSurface^.TopLeftColor)+');'#10+
                 aSpacePrefix+'TopRightColor.Value := '+BGRAToPascal(aSurface^.TopRightColor)+');'#10+
                 aSpacePrefix+'BottomRightColor.Value := '+BGRAToPascal(aSurface^.BottomRightColor)+');'#10+
                 aSpacePrefix+'BottomLeftColor.Value := '+BGRAToPascal(aSurface^.BottomLeftColor)+');';
      end;
    end;

    'TGradientRectangle': begin
      Result := aSpacePrefix+'LoadGradientDataFromString('''+aSurface^.GradientData+''');'#10+
                aSpacePrefix+'SetSize(ScaleW('+aSurface^.width.ToString+'), ScaleH('+aSurface^.height.ToString+'));';
    end;

    'TDeformationGrid': begin
      Result := aSpacePrefix+'SetSize(ScaleW('+aSurface^.width.ToString+'), ScaleH('+aSurface^.height.ToString+'));'#10+
                aSpacePrefix+'LoadDeformationDataFromString('''+aSurface^.DeformationGridData+''');';

    end

    else raise exception.Create('forgot to implement '+aSurface^.classtype.ClassName);
  end;
end;

procedure AddFileGeneratedByGameHelper(t: TStringList);
begin
  t.Add('  File generated by GameHelper, tool provided with OGLCScene library.');
end;

procedure AddInterface(t: TStringList; const aUnitName: string);
begin
  t.AddText('unit '+aUnitName+';'#10#10+
            '{$mode ObjFPC}{$H+}'#10#10+
            'interface'#10#10+
            'uses'#10#10+
            '  Classes, SysUtils,'#10+
            '  OGLCScene, BGRABitmap, BGRABitmapTypes, u_common;'#10#10+
            'type'#10#10);
end;

procedure AddDeclarationOfDecorClass(t: TStringList; const aClassName: string);
begin
  t.Add('{ '+aClassName+' }');
  t.Add('');
  t.AddText(aClassName+' = class(TOGLCDecorManager)'#10+
            'protected'#10+
            '  function ScaleWF(AValue: single): single; override;'#10+
            '  function ScaleHF(AValue: single): single; override;'#10+
            'public'#10+
            '  class procedure LoadTexture(aAtlas: TAtlas); override;');
  if LevelBank.Size > 1 then t.Add('  procedure BuildLevel(aIndex: integer);')
    else t.Add('  procedure BuildLevel;');
  t.Add('end;'#10);
end;

procedure AddDeclarationOfProtectedFlipHAndFlipVForApplySymmetryWhenFlip(t: TStringList);
begin
  t.AddText('  procedure SetFlipH(AValue: boolean); override;'#10+
            '  procedure SetFlipV(AValue: boolean); override;');
end;

procedure AddDeclarationOfClassLoadTexture(t: TStringList);
begin
  t.Add('  class procedure LoadTexture(aAtlas: TOGLCTextureAtlas);');
end;

procedure AddDeclarationOfSurfaceConstructor(t: TStringList);
begin
  t.Add('  constructor Create(aLayerIndex: integer=-1);');
end;

procedure AddDeclarationOfProcessMessage(t: TStringList);
begin
  t.Add('  procedure ProcessMessage(UserValue: TUserMessageValue); override;');
end;

procedure AddImplementation(t: TStringList);
begin
  t.Add('implementation');
  t.Add('');
end;

procedure AddImplementationOfDecorProtectedMethod(t: TStringList; const aDecorClassName: string);
begin
  t.AddText('function '+aDecorClassName+'.ScaleWF(AValue: single): single;'#10+
            'begin'#10+
            '  Result := u_common.ScaleWF(AValue);'#10+
            'end;'#10#10+
            'function '+aDecorClassName+'.ScaleHF(AValue: single): single;'#10+
            'begin'#10+
            '  Result := u_common.ScaleHF(AValue);'#10+
            'end;'#10);
end;

procedure AddImplementationOfDecorBuildLevel(t: TStringList; const aDecorClassName: string);
var i: SizeUInt;
begin
  if LevelBank.Size > 1 then begin
    // several decors
    t.AddText('procedure '+aDecorClassName+'.BuildLevel(aIndex: integer);'#10+
              'begin'#10+
              '  case aIndex of');
    for i:=0 to LevelBank.Size-1 do
      t.Add('    '+i.ToString+': DoBuildLevel('+'Data_'+LevelBank.Mutable[i]^.name+');');
    t.AddText('    else raise exception.create(''level index out of bounds'');'#10+
              '  end;'#10+
              'end;'#10#10);
  end else begin
    // only one decor
    t.AddText('procedure '+aDecorClassName+'.BuildLevel;'#10+
              'begin'#10+
              '  DoBuildLevel('+'Data_'+LevelBank.Mutable[0]^.name+');'#10+
              'end;');
  end;
end;

procedure AddImplementationOfProcessMessage(t: TStringList; const aClassName: string);
begin
  t.AddText('procedure '+aClassName+'.ProcessMessage(UserValue: TUserMessageValue);'#10+
            'begin'#10+
            '  case UserValue of'#10+
            '    0: begin'#10+
            '    end;'#10+
            '  end;//case'#10+
            'end;'#10);
end;

procedure ExportSpriteToPascalUnit(t: TStringList;
  aTextures: TTextureList; aSurfaces: TSurfaceList;  aPostures: TPostureList;
  aSpriteNameInBank, aSpriteClassName, aTargetFilename: string;
  aApplySymmetryWhenFlip, aOverrideProcessMessage: boolean);
var i, j, c: integer;
  s, sw, sh, sx, sy, texFilename, spriteClassType: string;
  rootItem, current, _parent: PSurfaceDescriptor;
  bodyItem: PBodyItem;
  p: SizeInt;
  bodyList: TBodyItemList;
  pt: TPostureValues;
  pf: TPointF;
  function Generate_AngleChangeTo(aAngle: single; const aSurfaceName: string): string;
  begin
    Result :='  '+aSurfaceName+'.Angle.ChangeTo(';
    if aAngle = 0 then Result := Result+'0'
      else Result := Result+FormatFloatWithDot('0.000', aAngle);
    Result := Result+', aDuration, idcSinusoid);';
  end;
  function Generate_ScaleChangeTo(aScaleX, aScaleY: single; const aSurfaceName: string): string;
  begin
    Result := '  '+aSurfaceName+'.Scale.ChangeTo(PointF(';
    if aScaleX = 1.0 then Result := Result+'1.0'
      else Result := Result+FormatFloatWithDot('0.000', aScaleX);
    Result := Result + ', ';
    if aScaleY = 1.0 then Result := Result+'1.0'
      else Result := Result+FormatFloatWithDot('0.000', aScaleY);
    Result := Result + '), aDuration, idcSinusoid);';
  end;
  function FormatXCoorRelativeToParentWidth(aX: single; const aSurfaceName: string): string;
  begin
    if aX = 0 then Result := '0'
      else begin
        if aSurfaceName <> '' then
          Result := FormatFloatWithDot('0.000', aX)+'*'+aSurfaceName+'.Width'
        else
          Result := FormatFloatWithDot('0.000', aX)+'*'+'Width';
      end;
  end;
  function FormatYCoorRelativeToParentHeight(aY: single; const aSurfaceName: string): string;
  begin
    if aY = 0 then Result := '0'
      else begin
        if aSurfaceName <> '' then
          Result := FormatFloatWithDot('0.000', aY)+'*'+aSurfaceName+'.Height'
        else
          Result := FormatFloatWithDot('0.000', aY)+'*'+'Height';
      end;
  end;
begin
  rootItem := aSurfaces.GetRootItem;
  spriteClassType := rootItem^.surface.ClassName;
  // header
  t.Add('{');
  AddFileGeneratedByGameHelper(t);
  t.AddText('  Usage:'#10+
            '    - include this file to your Lazarus project.');
  if aSurfaces.UseTexture then
    t.Add('    - call '+aSpriteClassName+'.LoadTexture() when you construct your texture atlas.');
  t.AddText('    - create an instance of the sprite as usual.'#10+
           '}');
  t.Add('');
  AddInterface(t, ChangeFileExt(ExtractFilename(aTargetFilename), ''));

  // class declaration
  t.Add(aSpriteClassName+' = class('+spriteClassType+')');

  // textures declaration
  if aTextures.Size > 0 then begin
    t.AddText('private');
    s := '  class var ';
    for i:=0 to aTextures.Size-1 do begin
      s := s + aTextures.Mutable[i]^.name;
      if i < aTextures.Size-1 then s := s +', ';
      if (i mod 4 = 0) and (i > 0) and (i < aTextures.Size-1) then s := s + #10'  ';
    end;
    s := s + ': PTexture;';
    t.AddText(s);
  end;

  // child variables declaration
  t.Add('private');
  s := '';
  for i:=0 to aSurfaces.Size-1 do begin
    current := aSurfaces.Mutable[i];
    if current = rootItem then continue;
    s := s + '  '+current^.name+': '+current^.classtype.ClassName+';';
    if i < aSurfaces.Size-1 then s := s +#10;
  end;
  t.AddText(s);

  // flipH and flipV for ApplySymmetryWhenFlip
  if aApplySymmetryWhenFlip then begin
    t.Add('protected');
    AddDeclarationOfProtectedFlipHAndFlipVForApplySymmetryWhenFlip(t);
  end;

  // methods declaration
  t.Add('public');
  if aTextures.Size > 0 then
    AddDeclarationOfClassLoadTexture(t);
  AddDeclarationOfSurfaceConstructor(t);
  if aOverrideProcessMessage then
    AddDeclarationOfProcessMessage(t);

  // methods declaration for posture
  if aPostures.Size > 0 then begin
    s := 'public'#10;
    for i:=0 to aPostures.Size-1 do begin
      s := s+'  procedure Posture_'+aPostures.Mutable[i]^.name+'(aDuration: single=0.5);';
      if i < aPostures.Size-1 then s := s+#10;
    end;
    t.AddText(s);
  end;


  t.Add('end;');   // end of class declaration
  t.Add('');
  AddImplementation(t);
  t.Add('{ '+aSpriteClassName+' }');
  t.Add('');

  // procedure load Texture
  if aTextures.Size > 0 then begin
    t.AddText('class procedure '+aSpriteClassName+'.LoadTexture(aAtlas: TOGLCTextureAtlas);'#10+
              'var dataFolder: string;'#10+
              'begin'#10+
              '  dataFolder := u_common.DataFolder;');
    for i:=0 to aTextures.Size-1 do begin
      // texture filename must be relative to application Data folder
      texFilename := aTextures.Mutable[i]^.filename;
      p := texFilename.LastIndexOf(DirectorySeparator+'Data'+DirectorySeparator);
      texFilename := texFilename.Remove(0, p+6);
      texFilename := 'dataFolder+'''+texFilename+'''';

      s := '  '+aTextures.Mutable[i]^.name + ' := ';
      if ExtractFileExt(aTextures.Mutable[i]^.filename) = '.svg' then begin
        if aTextures.Mutable[i]^.width = -1 then sw := '-1'
          else sw := 'ScaleW('+aTextures.Mutable[i]^.width.ToString+')';
        if aTextures.Mutable[i]^.height = -1 then sh := '-1'
          else sh := 'ScaleH('+aTextures.Mutable[i]^.height.ToString+')';

        if aTextures.Mutable[i]^.isMultiFrame then
          s := s + 'aAtlas.AddMultiFrameImageFromSVG('+texFilename+
             ', '+sw+', '+sh+
             ', '+(aTextures.Mutable[i]^.width div aTextures.Mutable[i]^.frameWidth).ToString+
             ', '+(aTextures.Mutable[i]^.height div aTextures.Mutable[i]^.frameHeight).ToString+
             ', 0);'
        else
          s := s + 'aAtlas.AddFromSVG('+texFilename+', '+sw+', '+sh+');';
      end else begin
        if aTextures.Mutable[i]^.isMultiFrame then
          s := s + 'aAtlas.AddMultiFrameImage('+texFilename+
          ', '+(aTextures.Mutable[i]^.width div aTextures.Mutable[i]^.frameWidth).ToString+
          ', '+(aTextures.Mutable[i]^.height div aTextures.Mutable[i]^.frameHeight).ToString+');'
        else
          s := s + 'aAtlas.Add('+texFilename+');';
      end;
      t.Add(s);
    end;
    t.AddText('end;'#10+#10);
  end;

  // procedure SetFlipH and SetFlipV
  if aApplySymmetryWhenFlip then begin
    t.AddText('procedure '+aSpriteClassName+'.SetFlipH(AValue: boolean);'#10+
              'begin'#10+
              '  inherited SetFlipH(AValue);');
    s := '';
    for i:=0 to aSurfaces.Size-1 do begin
      current := aSurfaces.Mutable[i];
      if (rootItem <> NIL) and (current = rootItem) then continue;
      if current^.flipH then t.Add('  '+current^.name+'.FlipH := not AValue;')
        else t.Add('  '+current^.name+'.FlipH := AValue;');
      if current^.FlipV then s := s+'  '+current^.name+'.FlipV := not AValue;'
        else s := s+'  '+current^.name+'.FlipV := AValue;';
      if i < aSurfaces.Size-1 then s := s + #10;
    end;
    t.AddText('end;'#10+#10+
              'procedure '+aSpriteClassName+'.SetFlipV(AValue: boolean);'#10+
              'begin'#10+
              '  inherited SetFlipV(AValue);'#10+
              s+#10+
              'end;');
    t.Add('');
  end;

  // constructor
  t.AddText('constructor '+aSpriteClassName+'.Create(aLayerIndex: integer);'#10+
            'begin'#10);
  case aSpriteClassName of
    'TSpriteContainer': begin
      s := '  inherited Create(FScene);';
    end;
    'TSprite', 'TSpriteWithElasticCorner', 'TTiledSprite', 'TPolarSprite', 'TScrollableSprite': begin
      s := '  inherited Create('+rootItem^.textureName + ', False);';
    end;
    'TShapeOutline': begin
      s := '  inherited Create(FScene);';
    end;
    'TGradientRectangle': begin
      s := '  inherited Create(FScene);';
    end;
    'TQuad4Color': begin
      s := '  inherited Create(FScene);'#10+
           ExtraPropertiesToPascalCode(rootItem, '  ');
    end;
    'TDeformationGrid': begin
      s := '  inherited Create('+rootItem^.textureName + ', False);';
    end;
    else raise exception.create('forgot to implement '+aSpriteClassName);
  end;
  t.Add(s);
  t.AddText('  if aLayerIndex <> -1 then'#10+
            '    FScene.Add(Self, aLayerIndex);'#10);
  if rootItem <> NIL then begin
    if (rootItem^.x <> 0.0) or (rootItem^.y <> 0.0) then
      t.Add('  SetCoordinate('+FormatFloatWithDot('0.00', rootItem^.x)+', '+
                               FormatFloatWithDot('0.00', rootItem^.y)+');');

    t.AddText(CommonPropertiesToPascalCode(rootItem, '  '));
    t.AddText(ExtraPropertiesToPascalCode(rootItem, '  '));
    t.Add('');
  end else t.Add('');

  // creating childs
  for i:=0 to aSurfaces.Size-1 do begin
    current := aSurfaces.Mutable[i];
    // copy values to variable for easier access
    current^.DuplicateValuesToTemporaryVariables;

    if (rootItem <> NIL) and (current = rootItem) then continue;

    case current^.classtype.ClassName of
      'TSpriteContainer': s := '  '+current^.name+' := TSpriteContainer.Create(FScene)'#10;
      'TSprite': s := '  '+current^.name+' := TSprite.Create('+current^.textureName+', False);';
      'TQuad4Color': s := '  '+current^.name+' := TQuad4Color.Create(FScene);';
      'TGradientRectangle': s := '  '+current^.name+' := TGradientRectangle.Create(FScene);';
      'TDeformationGrid': s := '  '+current^.name+' := TDeformationGrid.Create('+current^.textureName+', False);';
      else raise exception.create('forgot to implement '+current^.classtype.ClassName);
    end;

    t.Add(s);
    // set child dependency and values
    _parent := aSurfaces.GetItemByID(current^.parentID);
    if rootItem = NIL then begin
      if current^.parentID = -1 then s := 'Self'
        else s := _parent^.name;
    end else begin
      if current^.parentID = rootItem^.id then s := 'Self'
        else s := _parent^.name;
    end;
    t.AddText('  with '+current^.name+' do begin'#10+
              '    SetChildOf('+s+', '+current^.zOrder.ToString+');');

    // to keep right proportion, coordinates must be relative to
    // the width and height of the parent or current
    if (current^.x <> 0) or (current^.y <> 0) then begin
      if _parent^.classtype = TSpriteContainer then begin
        sx := FormatXCoorRelativeToParentWidth(current^.x/current^.surface.Width, current^.name);
        sy := FormatYCoorRelativeToParentHeight(current^.y/current^.surface.Height, current^.name);
      end else begin
        if _parent^.IsRoot then begin
          sx := FormatXCoorRelativeToParentWidth(current^.x/_parent^.surface.Width, 'Self');
          sy := FormatYCoorRelativeToParentHeight(current^.y/_parent^.surface.Height, 'Self');
        end else begin
          sx := FormatXCoorRelativeToParentWidth(current^.x/_parent^.surface.Width, _parent^.name);
          sy := FormatYCoorRelativeToParentHeight(current^.y/_parent^.surface.Height, _parent^.name);
        end;
      end;
      t.Add('    SetCoordinate('+sx+', '+sy+');');
    end;

    t.AddText(CommonPropertiesToPascalCode(current, '    '));
    t.AddText(ExtraPropertiesToPascalCode(current, '    '));
    if aApplySymmetryWhenFlip then
      t.Add('    ApplySymmetryWhenFlip := True;');
    t.Add('  end;');
    if i < aSurfaces.Size-1 then t.Add('');
  end;//for

  // create collision bodies
  bodyList := TBodyItemList.Create;
  bodyList.LoadFromString(SpriteBank.GetItemByName(aSpriteNameInBank)^.collisionbodies);

  if bodyList.Size > 0 then begin
    t.Add('  // Collision body');
    for i:=0 to bodyList.Size-1 do begin
      bodyItem := bodyList.Mutable[i];
      // to keep right proportion, coordinates must be relative to
      // the width and height
      case bodyItem^.BodyType of
        _btPoint: begin
          pf := bodyItem^.ItemDescriptor.pt;
          s := '  CollisionBody.AddPoint(';
          s := s + 'PointF('+FormatXCoorRelativeToParentWidth(pf.x/rootItem^.surface.Width, '')+
                   ', '+FormatYCoorRelativeToParentHeight(pf.y/rootItem^.surface.Height, '')+
                   ')';
          t.Add(s);
        end;
        _btLine: begin
          pf := bodyItem^.ItemDescriptor.pt1;
          s := '  CollisionBody.AddLine(';
          s := s + 'PointF('+FormatXCoorRelativeToParentWidth(pf.x/rootItem^.surface.Width, '')+
                   ', '+FormatYCoorRelativeToParentHeight(pf.y/rootItem^.surface.Height, '')+
                   '), ';
          pf := bodyItem^.ItemDescriptor.pt2;
          s := s + 'PointF('+FormatXCoorRelativeToParentWidth(pf.x/rootItem^.surface.Width, '')+
                   ', '+FormatYCoorRelativeToParentHeight(pf.y/rootItem^.surface.Height, '')+
                   '));';
          t.Add(s);

{          t.Add('  CollisionBody.AddLine('+PointFToPascal(bodyItem^.ItemDescriptor.pt1)+'*FAdditionalScale, '+
                                    PointFToPascal(bodyItem^.ItemDescriptor.pt2)+'*FAdditionalScale);');  }
        end;
        _btCircle: begin
          pf := bodyItem^.ItemDescriptor.center;
          s := '  CollisionBody.AddCircle(';
          s := s + 'PointF('+FormatXCoorRelativeToParentWidth(pf.x/rootItem^.surface.Width, '')+
                   ', '+FormatYCoorRelativeToParentHeight(pf.y/rootItem^.surface.Height, '')+
                   '), ';
          s := s + FormatXCoorRelativeToParentWidth(bodyItem^.ItemDescriptor.radius, '')+');';
          t.Add(s);

        //  t.Add('  CollisionBody.AddCircle('+PointFToPascal(bodyItem^.ItemDescriptor.center)+'*FAdditionalScale, '+
        //                              FormatFloatWithDot('0.00', bodyItem^.ItemDescriptor.radius)+'*FAdditionalScale);');
        end;
        _btRect: begin
          pf := bodyItem^.ItemDescriptor.rect.TopLeft;
          s := '  CollisionBody.AddRect(';
          s := s + 'PointF('+FormatXCoorRelativeToParentWidth(pf.x/rootItem^.surface.Width, '')+
                   ', '+FormatYCoorRelativeToParentHeight(pf.y/rootItem^.surface.Height, '')+
                   '), ';
          pf := bodyItem^.ItemDescriptor.rect.BottomRight;
          s := s + 'PointF('+FormatXCoorRelativeToParentWidth(pf.x/rootItem^.surface.Width, '')+
                   ', '+FormatYCoorRelativeToParentHeight(pf.y/rootItem^.surface.Height, '')+
                   '));';
          t.Add(s);

         // t.Add('  CollisionBody.AddRect(RectF('+PointFToPascal(bodyItem^.ItemDescriptor.rect.TopLeft)+'*FAdditionalScale, '+
         //                                 PointFToPascal(bodyItem^.ItemDescriptor.rect.BottomRight)+'*FAdditionalScale));');
        end;
        _btPolygon: begin
          if Length(bodyItem^.ItemDescriptor.pts) = 0 then continue;
          s := '  CollisionBody.AddPolygon([';
          c := 0;
          for j:=0 to High(bodyItem^.ItemDescriptor.pts) do begin
            pf := bodyItem^.ItemDescriptor.pts[j];
            s := s + 'PointF('+FormatXCoorRelativeToParentWidth(pf.x/rootItem^.surface.Width, '')+
                     ', '+FormatYCoorRelativeToParentHeight(pf.y/rootItem^.surface.Height, '')+
                     ')';
            //s := s + PointFToPascal(bodyItem^.ItemDescriptor.pts[j])+'*FAdditionalScale';
            if j < High(bodyItem^.ItemDescriptor.pts) then s := s+', ';
            inc(c);
            if (c mod 2 = 0) and (j > 0) and (j < Length(bodyItem^.ItemDescriptor.pts)-1) then s := s + #10'    ';
          end;
          s := s+']);';
          t.AddText(s);
        end;
      end;//case
    end;
  end;
  bodyList.Free;

  t.Add('end;');
  t.Add('');

  // method ProcessMessage()
  if aOverrideProcessMessage then
    AddImplementationOfProcessMessage(t, aSpriteClassName);

  // methods for postures
  if aPostures.Size > 0 then begin
    for i:=0 to aPostures.Size-1 do begin
      t.AddText('procedure '+aSpriteClassName+'.Posture_'+aPostures.Mutable[i]^.name+'(aDuration: single);'#10+
                'begin');
      for j:=0 to aSurfaces.Size-1 do begin
        current := aSurfaces.Mutable[j];
        if current = rootItem then continue;
        _parent := aSurfaces.GetItemByID(current^.parentID);
        // copy values to variable for easier access
        current^.DuplicateValuesToTemporaryVariables;

        // to keep right proportion, coordinates must be relative to
        // the width and height of the parent or current
        pt := aPostures.Mutable[i]^.Values[j];
        if _parent^.classtype = TSpriteContainer then begin
          sx := FormatXCoorRelativeToParentWidth(pt.x/current^.surface.Width, current^.name);
          sy := FormatYCoorRelativeToParentHeight(pt.y/current^.surface.Height, current^.name);
        end else begin
          if _parent^.IsRoot then begin
            sx := FormatXCoorRelativeToParentWidth(pt.x/_parent^.surface.Width,'Self');
            sy := FormatYCoorRelativeToParentHeight(pt.y/_parent^.surface.Height, 'Self');
          end else begin
            sx := FormatXCoorRelativeToParentWidth(pt.x/_parent^.surface.Width, _parent^.name);
            sy := FormatYCoorRelativeToParentHeight(pt.y/_parent^.surface.Height, _parent^.name);
          end;
        end;
        t.Add('  '+current^.name+'.MoveTo('+sx+', '+sy+', aDuration, idcSinusoid);');

        t.Add(Generate_AngleChangeTo(aPostures.Mutable[i]^.Values[j].angle, current^.name));
        t.Add(Generate_ScaleChangeTo(aPostures.Mutable[i]^.Values[j].scalex, aPostures.Mutable[i]^.Values[j].scaley, current^.name));
      end;
      t.Add('end;');
      t.Add('');
    end;
  end;

  t.Add('end.');
end;

{ TArrayOfIntegerHelper }

function TArrayOfIntegerHelper.Count: integer;
begin
  Result := Length(Self);
end;

function TArrayOfIntegerHelper.Have(aValue: integer): boolean;
var i: integer;
begin
  for i:=0 to High(Self) do
    if Self[i] = aValue then exit(True);
  Result := False;
end;

function TArrayOfIntegerHelper.IndexOf(aValue: integer): integer;
var i: integer;
begin
  for i:=0 to High(Self) do
    if Self[i] = aValue then exit(i);
  Result := -1;
end;

procedure TArrayOfIntegerHelper.Add(aValue: integer);
begin
  SetLength(Self, Length(Self)+1);
  Self[High(Self)] := aValue;
end;

procedure TArrayOfIntegerHelper.AddOnlyOneTime(aValue: integer);
begin
  if not Have(aValue) then Add(aValue);
end;

procedure TArrayOfIntegerHelper.SortFromSmallToHigh;
var i, k: integer;
  flag: boolean;
begin
  repeat
    flag := False;
    for i:=0 to High(Self)-1 do
      if Self[i] > Self[i+1] then begin
        k := Self[i+1];
        Self[i+1] := Self[i];
        Self[i] := k;
        flag := true;
      end;
  until not flag;
end;

end.

