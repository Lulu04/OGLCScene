{$ifdef oglcINTERFACE}
const
  OGLC_DEFAULT_CHAR_SET = ' '+
                          '0123456789'+
                          '?!,.;:/*-+=()[]@'+
                          'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'+
                          'éèêëàâæçùûüïîôœÿß'+
                          'ÀÂÆÇÉÈÊËÎÏÔŒÙÛÜŸ';
type

// TO DO: rewrite all !
// construct an image with each character in the charset.

TTexturedChar = record
  Character: string;
  CharSize : TSize;    // in pixel
  TexCoor  : TTexCoor; // coordinates of the part of the texture for this character
end;
PTexturedChar=^TTexturedChar;

{ TTexturedFont }

TTexturedFont = class
  Constructor Create( aFont: TGuiFont; const aCharSet: string);
  Destructor Destroy; override;
 private
  FTexture: PTexture;
  FTexCharArray: array of TTexturedChar ;
  FFont: TGuiFont;
  function IndexOf( c: string ): integer;
  procedure BuildTexture( aFont: TGuiFont; const aCharSet: string );
  function GetTexturedChar( aChar: string ): PTexturedChar;
  procedure DrawChar( aChar: PTexturedChar; const aLoc: TPointF; const aLayerPercentOpacity: single );
 public
  procedure DrawText( aText: string; aLocation: TPointF; const aLayerPercentOpacity: single );
  function GetCharWidth( const c: string ): integer;
  function GetCharHeight( const c: string ): integer;
  function GetCharSize( const c: string ): TSize;
end;


{ TFontManager }

TFontManager = class
 constructor Create;
 Destructor Destroy; override;
private
 FList: TList;
public
 function AddFont( aGuiFont: TGuiFont; const aCharSet: string=OGLC_DEFAULT_CHAR_SET): TTexturedFont;
 procedure DeleteFont( var aFont: TTexturedFont );
 procedure Clear;
end;

var
 FontManager : TFontManager ;

 {$endif oglcINTERFACE}
 {$ifdef oglcIMPLEMENTATION}
 { TTexturedFont }

  constructor TTexturedFont.Create(aFont: TGuiFont; const aCharSet: string);
 begin
  SetLength( FTexCharArray, 0 );
  BuildTexture( aFont, aCharSet );
 end;

 destructor TTexturedFont.Destroy;
 begin
  TextureManager.Delete( FTexture );
  SetLength( FTexCharArray, 0 );
  inherited Destroy;
 end;

 function TTexturedFont.IndexOf(c: string): integer;
 var i: integer;
 begin
  Result := -1;
  for i:=0 to Length(FTexCharArray)-1 do
   if c = FTexCharArray[i].Character
      then begin
            Result := i;
            exit ;
           end;
 end;


 procedure TTexturedFont.BuildTexture(aFont: TGuiFont; const aCharSet: string);
 var i, j, xx, yy, maxCharHeight : integer;
     ima, imaChar: TBGRABitmap;
     s1 : string;
     renderer: TBGRATextEffectFontRenderer;
 begin
  FFont := aFont;

  renderer:= TBGRATextEffectFontRenderer.Create;
  with FFont do begin
    renderer.ShadowVisible := ShadowColor<>BGRAPixelTransparent;
    renderer.ShadowColor := ShadowColor;
    renderer.ShadowOffset.x := ShadowOffsetX;
    renderer.ShadowOffset.y := ShadowOffsetY;
    renderer.ShadowRadius := ShadowRadius;
    renderer.OutlineVisible := (OutLineColor<>BGRAPixelTransparent) and (OutLineWidth>0);
    renderer.OutlineColor := OutLineColor;
    renderer.OuterOutlineOnly := True;
    renderer.OutlineWidth := OutLineWidth;

    ima:= TBGRABitmap.Create(TextureManager.GetMaxTextureWidth,
                             TextureManager.GetMaxTextureWidth);  // default max texture size
    ima.FontRenderer := renderer;
    ima.FontQuality:= fqFineAntialiasing;
    ima.FontName := FontName;
    ima.FontHeight := FontHeight;
    ima.FontStyle := Style;
  end;

  // build the font
  SetLength(FTexCharArray, UTF8Length(aCharSet));
  xx:=0;
  yy:=0;
  maxCharHeight:=0;
  for i:=0 to UTF8Length(aCharSet)-1 do
   begin
    s1 := UTF8Copy( aCharSet, i+1, 1 );
    imaChar := TextToBitmap( s1, FFont );

    if xx+imaChar.Width>1024 then begin
          // next line
          xx := 0;
          yy += maxCharHeight;
    end;

    ima.PutImage(xx, yy, imaChar, dmDrawWithTransparency);
    if maxCharHeight< imaChar.Height then maxCharHeight:=imaChar.Height;
    xx += imachar.Width;

    FTexCharArray[i].Character := s1;
    FTexCharArray[i].CharSize := Size(imaChar.Width, imaChar.Height);
    FTexCharArray[i].TexCoor[0].x := xx;
    FTexCharArray[i].TexCoor[0].y := yy;
    FTexCharArray[i].TexCoor[1].x := xx+imaChar.Width;
    FTexCharArray[i].TexCoor[1].y := yy;
    FTexCharArray[i].TexCoor[2].x := xx+imaChar.Width;
    FTexCharArray[i].TexCoor[2].y := yy+imaChar.Height;
    FTexCharArray[i].TexCoor[3].x := xx;
    FTexCharArray[i].TexCoor[3].y := yy+imaChar.Height;
   end;

  // TO DO: reduce the size of ima to remove the unused pixels

  // compute Texture coordinate for each character
  for i:=0 to Length(FTexCharArray)-1 do
    with FTexCharArray[i] do begin
     for j:=0 to 3 do begin
       TexCoor[j].x := TexCoor[j].x/ima.Width;
       TexCoor[j].y := TexCoor[j].y/ima.Height;
     end;
    end;

  FTexture := TextureManager.Add( ima );
  ima.Free;
 end;

 function TTexturedFont.GetTexturedChar(aChar: string): PTexturedChar;
 var i: integer;
 begin
  i := IndexOf( aChar );
  if i=-1
    then Result := NIL
    else Result := @FTexCharArray[i];
 end;

 procedure TTexturedFont.DrawChar(aChar: PTexturedChar; const aLoc: TPointF;
   const aLayerPercentOpacity: single);
 var
   quad : TTexCoor;
   tci  : PTextureCoordIndex;
   i: integer;
   procedure DrawVertex;
    begin
 {    glBegin( GL_TRIANGLES );
       glTexCoord2fv( @TexCoor[ tci^[ 0 ] ] );  glVertex2fv( @quad[ 0 ] );
       glTexCoord2fv( @TexCoor[ tci^[ 1 ] ] );  glVertex2fv( @quad[ 1 ] );
       glTexCoord2fv( @TexCoor[ tci^[ 3 ] ] );  glVertex2fv( @quad[ 3 ] );
     glEnd;
     glBegin( GL_TRIANGLES );
       glTexCoord2fv( @TexCoor[ tci^[ 1 ] ] );  glVertex2fv( @quad[ 1 ] );
       glTexCoord2fv( @TexCoor[ tci^[ 2 ] ] );  glVertex2fv( @quad[ 2 ] );
       glTexCoord2fv( @TexCoor[ tci^[ 3 ] ] );  glVertex2fv( @quad[ 3 ] );
     glEnd;  }
     glBegin( GL_QUADS );
       glTexCoord2fv( @aChar^.TexCoor[ tci^[ 0 ] ] );  glVertex2fv( @quad[ 0 ] );
       glTexCoord2fv( @aChar^.TexCoor[ tci^[ 1 ] ] );  glVertex2fv( @quad[ 1 ] );
       glTexCoord2fv( @aChar^.TexCoor[ tci^[ 2 ] ] );  glVertex2fv( @quad[ 2 ] );
       glTexCoord2fv( @aChar^.TexCoor[ tci^[ 3 ] ] );  glVertex2fv( @quad[ 3 ] );
     glEnd;
    end;
 begin

  quad[0] := aLoc;
  quad[1] := aLoc+PointF(aChar^.CharSize.cx,0);
  quad[2] := aLoc+PointF(aChar^.CharSize.cx,aChar^.CharSize.cy);
  quad[3] := aLoc+PointF(0,aChar^.CharSize.cy);

  tci := @FLIP_TEXCOORD[ 0 ];

  glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
  glColor4ub(255,255,255,round(255 * aLayerPercentOpacity));
  DrawVertex;
 end;

  procedure TTexturedFont.DrawText(aText: string; aLocation: TPointF;
   const aLayerPercentOpacity: single);
 var i: integer;
  tc: PTexturedChar;
 begin
  if aText='' then exit;
  if Length(FTexCharArray)=0 then exit;

  TextureManager.BindTexture( FTexture );

  for i:=1 to UTF8Length(aString) do begin
   tc := GetTexturedChar( UTF8Copy(aText,i,1) );
   if tc <> NIL then begin
      DrawChar( tc, aLocation, aLayerPercentOpacity );
      aLocation.x+=tc^.CharSize.cx;
   end;
  end;
 end;

 function TTexturedFont.GetCharWidth(const c: string): integer;
 var i: integer;
 begin
  i := IndexOf( c );
  if i=-1
    then Result := 0
    else Result := FTexCharArray[i].CharSize.cx ;
 end;

 function TTexturedFont.GetCharHeight(const c: string): integer;
 var i: integer;
 begin
  i := IndexOf( c );
  if i=-1
    then Result := 0
    else Result := FTexCharArray[i].CharSize.cy ;
 end;

 function TTexturedFont.GetCharSize(const c: string): TSize;
 var i: integer;
 begin
  i := IndexOf( c );
  if i=-1
    then Result := Size(0,0)
    else Result := FTexCharArray[i].CharSize ;
 end;

 constructor TFontManager.Create;
 begin
  inherited Create;
  FList := TList.Create;
 end;

 { TFontManager }
 destructor TFontManager.Destroy;
 begin
  Clear;
  FList.Free;
  inherited Destroy;
 end;

  function TFontManager.AddFont(aGuiFont: TGuiFont; const aCharSet: string): TTexturedFont;
 begin
  Result := TTexturedFont.Create( aGuiFont, aCharSet );
  FList.Add( Result );
 end;

 procedure TFontManager.DeleteFont(var aFont: TTexturedFont);
 var i: integer;
 begin
  if aFont=NIL then exit;
  i := FList.IndexOf( Pointer(aFont) );
  if i<> -1 then FList.delete( i );
  aFont.Free;
  aFont := NIL;
 end;

 procedure TFontManager.Clear;
 begin
  while FList.Count>0 do begin
   TTexturedFont(FList.Items[0]).Free;
   FList.Delete(0);
  end;
 end;


{$endif oglcIMPLEMENTATION}

