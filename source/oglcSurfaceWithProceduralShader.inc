{$ifdef oglcINTERFACE}
type

{ TOGLCBaseSurfaceWithProceduralShader }
// a surface with a procedural shader that draws an image in a texture.
// then the texture is used in a sprite.
TOGLCBaseSurfaceWithProceduralShader = class(TSimpleSurfaceWithEffect)
private
  FRendererToTexture: TOGLCRenderToTexture;
  FReady: boolean;
  function GetRenderedTexture: PTexture;
private
  FOnWriteUniformValues: TProcOfObject;
  FVBO, FVAO: GLuint;
  FGLErrorSent: boolean;
  FAttribsArray: TArrayOfxy;
  FWidth, FHeight: integer;
  FModelArea: TQuadCoor;
  FTimeAccu: single;
  procedure CreateID;
  procedure FreeID;
  procedure InitStaticVertexAttribs;
protected
  function GetWidth: integer; override;
  function GetHeight: integer; override;
public
  procedure Update(const aElapsedTime: single); override;
  procedure DoDraw; override;
public
  Shader: TOGLCShader;
  ProjectionMatrix: TOGLCMatrix;
  // aWidth, aHeight: the size of the texture to generate.
  // aVertexCodeSource, aFragmentCodeSource: the GLSL code for the vertex and the fragment shader.
  // aColorAttachmentIndex: the color attachment index to use to write into the texture.
  constructor Create(aParentScene: TOGLCScene;
                     aWidth, aHeight: integer;
                     const aVertexCodeSource, aFragmentCodeSource: string;
                     aColorAttachmentIndex: integer=0);
  Destructor Destroy; override;

  // True if all is ok
  property Ready: boolean read FReady;
  // Define the callback to initialize the values of the shader uniforms.
  // It's not necessary to call Shader.Use before initilizing your uniforms.
  property OnWriteUniformValues: TProcOfObject read FOnWriteUniformValues write FOnWriteUniformValues;
  property Renderer: TOGLCRenderToTexture read FRendererToTexture;
  // The output texture generated by the shader
  property RenderedTexture: PTexture read GetRenderedTexture;
  // the time in seconds since the creation of the object.
  property TimeAccu: single read FTimeAccu write FTimeAccu;
end;


{ TOGLCSpritePlanet }

TOGLCSpritePlanet = class(TOGLCSurfaceWithProceduralShader)
private const
  VERTEX_SHADER =
    '#version 330 core'#10+
    '  layout(location = 0) in vec2 aVertexCoor;'#10+
    '  uniform mat4 uMVP;'#10+
    'void main()'#10+
    '{'#10+
    '  gl_Position = uMVP*vec4(aVertexCoor.xy, 0.0, 1.0);'#10+
    '}';

// fragment shader is a modified version from
// https://docs.godotengine.org/en/stable/tutorials/shaders/using_viewport_as_texture.html
  FRAGMENT_SHADER =
    '#version 330 core'#10+
    '  layout(location = 0) out vec4 FragColor;'#10+
    '  uniform vec2 uTexSize;'#10+  // width and height of the target texture
    '  uniform float uTime;'#10+
    '  uniform vec3 uColorGround1 = vec3(0.9, 0.4, 0.4);'#10+
    '  uniform vec3 uColorGround2 = vec3(0.2, 0.6, 0.3);'#10+
    '  uniform vec3 uColorOcean = vec3(0.05, 0.3, 0.7);'#10+
    '  uniform vec4 uColorCloud = vec4(1.0, 1.0, 0.3, 0.3);'#10+
    '  uniform float uCloudAmount = 1.0;'#10+  // ]0..1]
    '  uniform vec3 uColorHalo = vec3(0.0,0.6,1.0);'#10+
    '  uniform float uHaloThreshold = 0.49;'#10+ // must be [0.1  to 0.49]
    '  uniform float uGroundAmount = 0.001;'#10+ // ]0..1]
    '  uniform float uLeftDarkAmount = 0.2;'#10+  // [0..1]
    'vec3 hash(vec3 p) {'#10+
    '    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),'#10+
    '             dot(p, vec3(269.5, 183.3, 246.1)),'#10+
    '             dot(p, vec3(113.5, 271.9, 124.6)));'#10+

    '    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);'#10+
    '}'#10+

    'float noise(vec3 p) {'#10+
    '  vec3 i = floor(p);'#10+
    '  vec3 f = fract(p);'#10+
    '  vec3 u = f * f * (3.0 - 2.0 * f);'#10+

    '  return mix(mix(mix(dot(hash(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)),'#10+
    '                     dot(hash(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),'#10+
    '                 mix(dot(hash(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)),'#10+
    '                     dot(hash(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),'#10+
    '             mix(mix(dot(hash(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)),'#10+
    '                     dot(hash(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),'#10+
    '                 mix(dot(hash(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0)),'#10+
    '                     dot(hash(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z );'#10+
    '}'#10+

    'mat2 scale(vec2 _scale){'#10+
    '    return mat2(_scale.x,0.0, 0.0,_scale.y);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '  vec2 UV = gl_FragCoord.xy / uTexSize.xy;'#10+
    '  vec2 UVOrigin = UV;'#10+


    // To move the surface we move the space
    '  vec2 translate = vec2(0.01*uTime,-0.4);'#10+
    '  UV += translate*0.35;'#10+

    // scale x 2
    '  UV -= vec2(0.5);'#10+
    '  UV = scale( vec2(0.5) ) * UV;'#10+
    '  UV += vec2(0.8);'#10+

    '  vec4 col = vec4(0.0, 0.0, 0.0, 0.0);'#10+
    '  float dist = distance(UVOrigin, vec2(0.5,0.5));'#10+
    '  if (dist <= 0.5)'#10+
    '  {'#10+
    '    float theta = UV.y * 3.14159;'#10+
    '    float phi = UV.x * 3.14159 * 2.0;'#10+
    '    vec3 unit = vec3(0.0, 0.0, 0.0);'#10+

    '    unit.x = sin(phi) * sin(theta);'#10+
    '    unit.y = cos(theta) * -1.0;'#10+
    '    unit.z = cos(phi) * sin(theta);'#10+
    '    unit = normalize(unit);'#10+
    '    float n = noise(unit * 5.0) * 0.5;'#10+
    '    n += noise(unit * 10.0) * 0.25;'#10+
    '    n += noise(unit * 20.0) * 0.125;'#10+
    '    n += noise(unit * 40.0) * 0.0625;'#10+
    '    vec3 groundColor = mix(uColorGround1, uColorGround2, smoothstep(-0.2, 0.0, n));'#10+
    '    float groundamount = uGroundAmount/100.0;'#10+
    '    col.rgb = mix(groundColor, uColorOcean, smoothstep(-0.1*groundamount, 0.0, n));'#10+
//    '    col.rgb = mix(uColorGround, uColorOcean, smoothstep(-0.1*groundamount, 0.0, n));'#10+

    // add clouds
    '    UV = UVOrigin;'#10+
    // To move the surface we move the space
    '    vec2 translate = vec2(0.01*uTime,-0.4);'#10+
    '    UV += translate*0.35;'#10+

    '    theta = UV.y * 3.14159;'#10+
    '    phi = UV.x * 3.14159 * 2.0;'#10+
    '    unit = vec3(0.0, 0.0, 0.0);'#10+

    '    unit.x = sin(phi) * sin(theta);'#10+
    '    unit.y = cos(theta) * -1.0;'#10+
    '    unit.z = cos(phi) * sin(theta);'#10+
    '    unit = normalize(unit);'#10+
    '    n = sin(noise(unit * 5.0 + vec3(uTime*0.05)) * 0.5);'#10+
    '    n += noise(unit * 10.0) * 0.25;'#10+
    '    n += noise(unit * 20.0) * 0.125;'#10+
    '    n += noise(unit * 40.0) * 0.0625;'#10+
    '    float cloudsamount = uCloudAmount / 100.0;'#10+
    '    col.rgb += uColorCloud.rgb * smoothstep(-0.1*cloudsamount, 0.0, n)*uColorCloud.a;'#10+

    // add darkness on the left of the planet
    '    col.rgb *= smoothstep(uLeftDarkAmount, 1.0, UVOrigin.x);'#10+

    // add halo around the planet
    '    if (dist > uHaloThreshold)'#10+
    '      {'#10+
    '        float a = 1.0 - smoothstep(uHaloThreshold, 0.5, dist);'#10+
    '        col = vec4(uColorHalo, a);'#10+
    '      }'#10+
    '      else '#10+
    // antialiasing on the edge of the planet
    '    if (dist > uHaloThreshold-0.02)'#10+
    '      {'#10+
    '        col.rgb = mix(col.rgb, uColorHalo, smoothstep(uHaloThreshold-0.02, uHaloThreshold, dist));'#10+
    '        col.a = 1.0;'#10+
    '      }'#10+
    '      else col.a = 1.0;'#10+
    '  }'#10+
    '  FragColor = col;'#10+
    '}';

private
  FLocMVP,
  FLocTexSize, FLocTime: glint;
  procedure DoWriteUniformValues;
public
  constructor Create(aParentScene: TOGLCScene;
                     aWidth, aHeight: integer;
                     aColorAttachmentIndex: integer=0);
end;

{$endif oglcINTERFACE}
{$ifdef oglcIMPLEMENTATION}

{ TOGLCBaseSurfaceWithProceduralShader }

procedure TOGLCBaseSurfaceWithProceduralShader.CreateID;
var err: GLenum;
begin
  if not FReady then exit;

  glGenVertexArrays(1, @FVAO);
  glGenBuffers(1, @FVBO);

  err := glGetError();
  if err <> GL_NO_ERROR then begin
    FReady := False;
    FParentScene.LogError(ClassName+'.CreateID: GL ERROR $'+IntToHex(err, 4)+' '+GLErrorToString(err));
  end;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.FreeID;
begin
  glDeleteBuffers(1, @FVBO);
  glDeleteVertexArrays(1, @FVAO);
  glGetError();
end;

function TOGLCBaseSurfaceWithProceduralShader.GetRenderedTexture: PTexture;
begin
  Result := FRendererToTexture.RenderedTexture;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.InitStaticVertexAttribs;
var p: Pxy;
  err: GLenum;
begin
  if not FReady then exit;

  FAttribsArray := NIL;
  SetLength(FAttribsArray, 4); // 2 x triangles strip
  p := @FAttribsArray[0];

  with p^ do begin
    x := FModelArea[cBL].x;
    y := FModelArea[cBL].y;
  end;
  inc(p);
  with p^ do begin
    x := FModelArea[cTL].x;
    y := FModelArea[cTL].y;
  end;
  inc(p);
  with p^ do begin
    x := FModelArea[cBR].x;
    y := FModelArea[cBR].y;
  end;
  inc(p);
  with p^ do begin
    x := FModelArea[cTR].x;
    y := FModelArea[cTR].y;
  end;

  glBindVertexArray(FVAO);
  // sets the size of the VBO
  glBindBuffer(GL_ARRAY_BUFFER, FVBO);
  glBufferData(GL_ARRAY_BUFFER, sizeof(Txy)*4, nil, GL_STATIC_DRAW);

  // define the vertex attributes
  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Txy), NIL);   // x y
  glEnableVertexAttribArray(0);

  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindVertexArray(0);

  // update buffer
  glBindBuffer(GL_ARRAY_BUFFER, FVBO);
  glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Txy)*4, @FAttribsArray[0]);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  err := glGetError();
  if err <> GL_NO_ERROR then begin
    FReady := False;
    FParentScene.LogError(ClassName+'.InitStaticVertexAttribs: GL ERROR $'+IntToHex(err, 4)+' '+GLErrorToString(err));
  end;
end;

function TOGLCBaseSurfaceWithProceduralShader.GetWidth: integer;
begin
  Result := FWidth;
end;

function TOGLCBaseSurfaceWithProceduralShader.GetHeight: integer;
begin
  Result := FHeight;
end;

constructor TOGLCBaseSurfaceWithProceduralShader.Create(aParentScene: TOGLCScene;
  aWidth, aHeight: integer; const aVertexCodeSource,
  aFragmentCodeSource: string; aColorAttachmentIndex: integer);
begin
  inherited Create;
  FParentScene := aParentScene;

  FRendererToTexture := TOGLCRenderToTexture.Create(aParentScene, aWidth, aHeight, aColorAttachmentIndex, False);
  if not FRendererToTexture.Ready then
    FParentScene.LogError(ClassName+'.Create: FRendererToTexture instance not ready');

  Shader.Compile(FRendererToTexture.FParentScene, aVertexCodeSource, aFragmentCodeSource);
  if not Shader.Ready then
    FParentScene.LogError(ClassName+'.Create: Shader instance not ready');

  FReady := Shader.Ready and FRendererToTexture.Ready;

  CreateID;

  FWidth := aWidth;
  FHeight := aHeight;
  FModelArea.SetAsRectangle(aWidth, aHeight);
  ProjectionMatrix.Ortho(0, aWidth, aHeight, 0, 0.0, 1.0);

  InitStaticVertexAttribs;
end;

destructor TOGLCBaseSurfaceWithProceduralShader.Destroy;
begin
  FRendererToTexture.Free;
  FRendererToTexture := NIL;
  Shader.FreeID;
  FreeID;
  FParentScene := NIL;
  inherited Destroy;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.Update(const aElapsedTime: single);
var err: GLenum;
begin
  inherited Update(aElapsedTime);

  if not FReady then exit;

  FTimeAccu := FTimeAccu + aElapsedTime;

  // flush the batch renderer process
  FParentScene.TexturedMVTriangleRenderer.Batch_Flush;

  // start the rendering into a texture
  FRendererToTexture.Bind;
  FRendererToTexture.ClearBuffers;

  // use shader and sets its uniform values
  Shader.Use;
  FOnWriteUniformValues();

  // draw the object into the texture
  glBindVertexArray(FVAO);
  glDrawArrays(GLenum(ptTriangleStrip), 0, 4);
  glBindVertexArray(0);

  // release shader
  Shader.Release;

  // stop the rendering into a texture and sets the viewport to the scene size
  FRendererToTexture.Unbind;
  glViewport(0, 0, FParentScene.Width, FParentScene.Height);

  err := glGetError();
  if (err <> GL_NO_ERROR) and not FGLErrorSent then begin
    FGLErrorSent := True;
    FParentScene.LogError(ClassName+'.Update(): GL ERROR $'+IntToHex(err, 4)+' '+GLErrorToString(err));
  end;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.DoDraw;
begin
  if not FReady then exit;

  FParentScene.TexturedMVTriangleRenderer.Prepare(ptTriangleStrip, FRendererToTexture.RenderedTexture, 0, BlendMode);
  FParentScene.TexturedMVTriangleRenderer.PushQuad2(FModelArea, FRendererToTexture.RenderedTexture^.FramesCoord[0], FlipToIndex,
                                                  NIL, FComputedOpacity, FComputedTint);
end;

{ TOGLCSpritePlanet }

procedure TOGLCSpritePlanet.DoWriteUniformValues;
begin
  if not Ready then exit;

  glUniformMatrix4fv(FLocMVP, 1, GL_FALSE, @ProjectionMatrix.Matrix[0,0]);
  glUniform2f(FLocTexSize, single(FWidth), single(FHeight));
  glUniform1f(FLocTime, TimeAccu);
end;

constructor TOGLCSpritePlanet.Create(aParentScene: TOGLCScene; aWidth,
  aHeight: integer; aColorAttachmentIndex: integer);
begin
  inherited Create(aParentScene, aWidth, aHeight, VERTEX_SHADER, FRAGMENT_SHADER, aColorAttachmentIndex);

  if Ready then
    with Shader do begin
      Use;
      FLocMVP := GetUniform('uMVP');
      FLocTexSize := GetUniform('uTexSize');
      FLocTime := GetUniform('uTime');
      Release;
    end;

  OnWriteUniformValues := @DoWriteUniformValues;
end;

{$endif oglcIMPLEMENTATION}

