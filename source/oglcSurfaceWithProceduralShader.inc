{$ifdef oglcINTERFACE}
type

{ TOGLCBaseSurfaceWithProceduralShader }
// a surface with a procedural shader that draws an image in a texture.
// then the texture is used in a sprite.

// this implementation is not good : it's better to separate the render to a texture by a shader
// from the surface part.
TOGLCBaseSurfaceWithProceduralShader = class(TSimpleSurfaceWithEffect)
private
  FRendererToTexture: TOGLCRenderToTexture;
  FReady: boolean;
  function GetRenderedTexture: PTexture;
private
  FOnWriteUniformValues: TProcOfObject;
  FVBO, FVAO: GLuint;
  FGLErrorSent: boolean;
  FAttribsArray: TArrayOfxyuv;
  FWidth, FHeight: integer;
  FModelArea: TQuadF;
  FTimeAccu: single;
  FRefreshContinuously, FRefreshOneTime: boolean;
  procedure CreateID;
  procedure FreeID;
  procedure InitStaticVertexAttribs;
protected
  function GetWidth: integer; override;
  function GetHeight: integer; override;
public
  procedure Update(const aElapsedTime: single); override;
  procedure DoDraw; override;
public
  Shader: TOGLCShader;
  ProjectionMatrix: TOGLCMatrix;
  // aWidth, aHeight: the size of the texture to generate.
  // aVertexCodeSource, aFragmentCodeSource: the GLSL code for the vertex and the fragment shader.
  // aColorAttachmentIndex: the color attachment index to use to write into the texture.
  constructor Create(aParentScene: TOGLCScene;
                     aWidth, aHeight: integer;
                     const aVertexCode, aFragmentCode: string;
                     aColorAttachmentIndex: integer=0);
  Destructor Destroy; override;

  // True if all is ok
  property Ready: boolean read FReady;
  // Define the callback to initialize the values of the shader uniforms.
  // It's not necessary to call Shader.Use before initilizing your uniforms.
  property OnWriteUniformValues: TProcOfObject read FOnWriteUniformValues write FOnWriteUniformValues;
  property RendererToTexture: TOGLCRenderToTexture read FRendererToTexture;
  // The output texture generated by the shader
  property RenderedTexture: PTexture read GetRenderedTexture;
  // the time in seconds since the creation of the object.
  property TimeAccu: single read FTimeAccu write FTimeAccu;
public
  // ask to refresh the image generated by the shader.
  // Use only when RefreshContinuously is set to False.
  // Call this procedure for example when you modify a uniform value.
  procedure RefreshOneTime;
  // setting this property to True involve on EACH FRAME:
  //      - OnWriteUniformValues callback is called
  //      - the image generated by the shader is refreshed
  // Use this feature only if you image is animated because it take more GPU resources.
  // Sets to False if your shader generate static image and call RefreshOneTime when you need.
  // default value is False.
  property RefreshContinuously: boolean read FRefreshContinuously write FRefreshContinuously;
end;

{$endif oglcINTERFACE}
{$ifdef oglcIMPLEMENTATION}

{ TOGLCBaseSurfaceWithProceduralShader }

procedure TOGLCBaseSurfaceWithProceduralShader.CreateID;
var err: GLenum;
begin
  if not FReady then exit;

  glGenVertexArrays(1, @FVAO);
  glGenBuffers(1, @FVBO);

  err := glGetError();
  if err <> GL_NO_ERROR then begin
    FReady := False;
    FParentScene.LogError(ClassName+'.CreateID: GL ERROR $'+IntToHex(err, 4)+' '+GLErrorToString(err));
  end;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.FreeID;
begin
  glDeleteBuffers(1, @FVBO);
  glDeleteVertexArrays(1, @FVAO);
  glGetError();
end;

function TOGLCBaseSurfaceWithProceduralShader.GetRenderedTexture: PTexture;
begin
  Result := FRendererToTexture.RenderedTexture;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.InitStaticVertexAttribs;
var p: Pxyuv;
  err: GLenum;
begin
  if not FReady then exit;

  FAttribsArray := NIL;
  SetLength(FAttribsArray, 4); // 2 x triangles strip
  p := @FAttribsArray[0];

  with p^ do begin
    x := FModelArea[cBL].x;
    y := FModelArea[cBL].y;
    u := 0;
    v := 0;
  end;
  inc(p);
  with p^ do begin
    x := FModelArea[cTL].x;
    y := FModelArea[cTL].y;
    u := 0;
    v := 1;
  end;
  inc(p);
  with p^ do begin
    x := FModelArea[cBR].x;
    y := FModelArea[cBR].y;
    u := 1;
    v := 0;
  end;
  inc(p);
  with p^ do begin
    x := FModelArea[cTR].x;
    y := FModelArea[cTR].y;
    u := 1;
    v := 1;
  end;

  glBindVertexArray(FVAO);
  // sets the size of the VBO
  glBindBuffer(GL_ARRAY_BUFFER, FVBO);
  glBufferData(GL_ARRAY_BUFFER, sizeof(Txyuv)*4, nil, GL_STATIC_DRAW);

  // define the vertex attributes
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, sizeof(Txyuv), NIL);   // x y u v
  glEnableVertexAttribArray(0);

  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindVertexArray(0);

  // update buffer
  glBindBuffer(GL_ARRAY_BUFFER, FVBO);
  glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Txyuv)*4, @FAttribsArray[0]);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  err := glGetError();
  if err <> GL_NO_ERROR then begin
    FReady := False;
    FParentScene.LogError(ClassName+'.InitStaticVertexAttribs: GL ERROR $'+IntToHex(err, 4)+' '+GLErrorToString(err));
  end;
end;

function TOGLCBaseSurfaceWithProceduralShader.GetWidth: integer;
begin
  Result := FWidth;
end;

function TOGLCBaseSurfaceWithProceduralShader.GetHeight: integer;
begin
  Result := FHeight;
end;

constructor TOGLCBaseSurfaceWithProceduralShader.Create(aParentScene: TOGLCScene;
  aWidth, aHeight: integer; const aVertexCode, aFragmentCode: string; aColorAttachmentIndex: integer);
begin
  inherited Create;
  FParentScene := aParentScene;

  FRendererToTexture := TOGLCRenderToTexture.Create(aParentScene, aWidth, aHeight, aColorAttachmentIndex, False);
  if not FRendererToTexture.Ready then
    FParentScene.LogError(ClassName+'.Create: FRendererToTexture instance not ready');

  Shader.Compile(FRendererToTexture.FParentScene, ClassName, aVertexCode, aFragmentCode);
  if not Shader.Ready then
    FParentScene.LogError(ClassName+'.Create: Shader instance not ready');

  FReady := Shader.Ready and FRendererToTexture.Ready;

  CreateID;

  FWidth := aWidth;
  FHeight := aHeight;
  FModelArea.SetAsRectangle(aWidth, aHeight);
  ProjectionMatrix.Ortho(0, aWidth, aHeight, 0, 0.0, 1.0);

  InitStaticVertexAttribs;

  FRefreshContinuously := False;
  FRefreshOneTime := True;
end;

destructor TOGLCBaseSurfaceWithProceduralShader.Destroy;
begin
  FRendererToTexture.Free;
  FRendererToTexture := NIL;
  Shader.FreeID;
  FreeID;
  FParentScene := NIL;
  inherited Destroy;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.RefreshOneTime;
begin
  FRefreshOneTime := True;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.Update(const aElapsedTime: single);
var err: GLenum;
begin
  inherited Update(aElapsedTime);

  if not FReady then exit;
  if not FRefreshOneTime and not FRefreshContinuously then exit;
  FRefreshOneTime := False;

  // time moves only if we want continuous animation
  if FRefreshContinuously then
    FTimeAccu := FTimeAccu + aElapsedTime;

  // flush the batch renderer process
  FParentScene.TexturedMVTriangleRenderer.Batch_Flush;

  // start the rendering into a texture
  FRendererToTexture.Bind;
  FRendererToTexture.ClearBuffers;

  // use shader and sets its uniform values
  Shader.Use;
  FOnWriteUniformValues();

  // draw the object into the texture
  glBindVertexArray(FVAO);
  glDrawArrays(GLenum(ptTriangleStrip), 0, 4);
  glBindVertexArray(0);

  // release shader
  Shader.Release;

  // stop the rendering into a texture and sets the viewport to the scene size
  FRendererToTexture.Unbind;
  glViewport(0, 0, FParentScene.Width, FParentScene.Height);

  err := glGetError();
  if (err <> GL_NO_ERROR) and not FGLErrorSent then begin
    FGLErrorSent := True;
    FParentScene.LogError(ClassName+'.Update(): GL ERROR $'+IntToHex(err, 4)+' '+GLErrorToString(err));
  end;
end;

procedure TOGLCBaseSurfaceWithProceduralShader.DoDraw;
begin
  if not FReady then exit;

  FParentScene.TexturedMVTriangleRenderer.Prepare(ptTriangleStrip, FRendererToTexture.RenderedTexture, 0, BlendMode);
  FParentScene.TexturedMVTriangleRenderer.PushQuad2(FModelArea, FRendererToTexture.RenderedTexture^.FramesCoord[0], FlipToIndex,
                                                  NIL, FComputedOpacity, FComputedTint);
end;

{$endif oglcIMPLEMENTATION}

